import{Vector3 as t,Vector2 as n,Box3 as i,Sphere as e,Mesh as s,BufferGeometry as o,BufferAttribute as r,Plane as a}from"three";class h{static generateUniform(n,i,e){const s=[],o=n.min,r=n.max,a=e?()=>e.random():()=>Math.random();for(let n=0;n<i;n++)s.push(new t(o.x+a()*(r.x-o.x),o.y+a()*(r.y-o.y),o.z+a()*(r.z-o.z)));return s}static generateImpactBased(n,i,e,s,o){const r=[],a=o?()=>o.random():()=>Math.random(),h=new t(Math.max(n.min.x,Math.min(n.max.x,e.x)),Math.max(n.min.y,Math.min(n.max.y,e.y)),Math.max(n.min.z,Math.min(n.max.z,e.z))),l=Math.floor(.6*i),u=i-l;for(let i=0;i<l;i++){const i=Math.pow(a(),2)*s,e=2*a()*Math.PI,o=Math.acos(2*a()-1),l=h.x+i*Math.sin(o)*Math.cos(e),u=h.y+i*Math.sin(o)*Math.sin(e),c=h.z+i*Math.cos(o);r.push(new t(Math.max(n.min.x,Math.min(n.max.x,l)),Math.max(n.min.y,Math.min(n.max.y,u)),Math.max(n.min.z,Math.min(n.max.z,c))))}return r.push(...this.generateUniform(n,u,o)),r}static generate2D(n,i,e,s){const o=[],r=n.min,a=n.max,h=new t((r.x+a.x)/2,(r.y+a.y)/2,(r.z+a.z)/2),l=s?()=>s.random():()=>Math.random();for(let n=0;n<i;n++){let n;n="x"===e?new t(h.x,r.y+l()*(a.y-r.y),r.z+l()*(a.z-r.z)):"y"===e?new t(r.x+l()*(a.x-r.x),h.y,r.z+l()*(a.z-r.z)):new t(r.x+l()*(a.x-r.x),r.y+l()*(a.y-r.y),h.z),o.push(n)}return o}static generate2DImpactBased(n,i,e,s,o,r){const a=[],h=n.min,l=n.max,u=new t((h.x+l.x)/2,(h.y+l.y)/2,(h.z+l.z)/2),c=r?()=>r.random():()=>Math.random();let g;g="x"===o?new t(u.x,e.y,e.z):"y"===o?new t(e.x,u.y,e.z):new t(e.x,e.y,u.z);const d=Math.floor(.6*i),p=i-d;for(let n=0;n<d;n++){const n=Math.pow(c(),2)*s,i=2*c()*Math.PI;let e;if("x"===o){const s=g.y+n*Math.cos(i),o=g.z+n*Math.sin(i);e=new t(u.x,Math.max(h.y,Math.min(l.y,s)),Math.max(h.z,Math.min(l.z,o)))}else if("y"===o){const s=g.x+n*Math.cos(i),o=g.z+n*Math.sin(i);e=new t(Math.max(h.x,Math.min(l.x,s)),u.y,Math.max(h.z,Math.min(l.z,o)))}else{const s=g.x+n*Math.cos(i),o=g.y+n*Math.sin(i);e=new t(Math.max(h.x,Math.min(l.x,s)),Math.max(h.y,Math.min(l.y,o)),u.z)}a.push(e)}return a.push(...this.generate2D(n,p,o,r)),a}static determineBestProjectionAxis(n){const i=new t(n.max.x-n.min.x,n.max.y-n.min.y,n.max.z-n.min.z);return i.x<=i.y&&i.x<=i.z?"x":i.y<=i.x&&i.y<=i.z?"y":"z"}}class l{constructor(t){this.seed=void 0!==t?t:Math.floor(2147483647*Math.random()),this.current=this.seed}getSeed(){return this.seed}random(){return this.current=(1664525*this.current+1013904223)%4294967296,this.current/4294967296}}const u=Math.max(1e-9,Number.EPSILON),c=.5*u,g=Math.log10(1/u),d=Math.pow(10,g),p=c*d;function x(t,n,i,e){return function(t,n,i,e,s){let o={x:n.x-t.x,y:n.y-t.y},r={x:e.x-i.x,y:e.y-i.y};const a=w(t),h=w(i);if(a===h)return s;const l=w(n);if(l===h)return s;const u=w(e);if(a===u)return s;if(l===u)return s;let c=(t.x-i.x)*r.y-(t.y-i.y)*r.x,g=(n.x-i.x)*r.y-(n.y-i.y)*r.x,d=(i.x-t.x)*o.y-(i.y-t.y)*o.x,p=(e.x-t.x)*o.y-(e.y-t.y)*o.x;return(c>=0&&g<=0||c<=0&&g>=0)&&(d>=0&&p<=0||d<=0&&p>=0)}(t,n,i,e,!1)}function m(n,i,e,s){let o=0,r=new t;return M(n)===M(i)||0===e.x&&0===e.y&&0===e.z?null:(o=((s.x-n.x)*e.x+(s.y-n.y)*e.y+(s.z-n.z)*e.z)/((i.x-n.x)*e.x+(i.y-n.y)*e.y+(i.z-n.z)*e.z),o>=0&&o<=1?(r=new t(n.x+(i.x-n.x)*o,n.y+(i.y-n.y)*o,n.z+(i.z-n.z)*o),{x:r,s:o}):null)}function f(t,n,i){return(n.x-t.x)*(i.y-t.y)-(n.y-t.y)*(i.x-t.x)<=0}function y(t){return~~(t*d+p)}function v(t,n){return Math.round((t+n)*(t+n+1)*.5+n)}function w(t){return v(y(t.x),y(t.y))}function M(t){return function(t,n,i){const e=(t+n)*(t+n+1)*.5+n;return(e+i)*(e+i+1)*.5+i}(y(t.x),y(t.y),y(t.z))}function z(t,n,i){return n.x*(t.x-i.x)+n.y*(t.y-i.y)+n.z*(t.z-i.z)>=0}class b{constructor(i=new t,e=new t,s=new n){this.position=i,this.normal=e,this.uv=s}clone(t){return new b(this.position.clone(),this.normal.clone(),this.uv.clone())}equals(t){return M(this.position)===M(t.position)}toString(){return`Position = ${this.position.x}, ${this.position.y}, ${this.position.z}, Normal = ${this.normal.x}, ${this.normal.y}, ${this.normal.z}, UV = ${this.uv.x}, ${this.uv.y}`}}const V=0,A=1;class C{constructor(t=null){this.isFragment=!0,this.vertices=[],this.cutVertices=[],this.triangles=[[],[]],this.constraints=[],this.indexMap=[],this.bounds=new i,this.vertexAdjacency=[],this.convextested=!1,this.minSize=.005,this.good=!0,null!==t&&this.fromArgs(t)}fromArgs(i){const{positions:e,normals:s,uvs:o,indices:r}=i;for(let i=0;i<e.length/3;i++){const r=new t(e[3*i],e[3*i+1],e[3*i+2]),a=new t(s[3*i],s[3*i+1],s[3*i+2]),h=o?new n(o[2*i],o[2*i+1]):new n(0,0);this.vertices.push(new b(r,a,h))}if(r)this.triangles=[Array.from(r),[]];else{const t=e.length/3;this.triangles=[Array.from({length:t},((t,n)=>n)),[]]}this.calculateBounds()}get valid(){let t=this.triangleCount>6&&this.vertexCount>14;return this.volume()<this.minSize&&(t=!1),t}get size(){this.bounds||this.calculateBounds();let n=new t;return this.bounds.getSize(n)}get convex(){return this.convextested||(this.cc=this.isConvex()),this.cc}get triangleCount(){return(this.triangles[0].length+this.triangles[1].length)/3}get vertexCount(){return this.vertices.length+this.cutVertices.length}addCutFaceVertex(t,n,i){const e=new b(t,n,i);this.vertices.push(e),this.cutVertices.push(e),this.vertexAdjacency.push(this.vertices.length-1)}addMappedVertex(t,n){this.vertices.push(t),this.indexMap[n]=this.vertices.length-1}addTriangle(t,n,i,e){this.triangles[e].push(t,n,i)}addMappedTriangle(t,n,i,e){this.triangles[e].push(this.indexMap[t],this.indexMap[n],this.indexMap[i])}weldCutFaceVertices(){const t=[],n=[],i=new Array(this.cutVertices.length);let e=0;const s=new Map;this.cutVertices.forEach(((o,r)=>{const a=M(o.position),h=s.get(a);s.has(a)?i[r]=h:(i[r]=e,s.set(a,e),t.push(this.cutVertices[r]),n.push(this.vertexAdjacency[r]),e++)}));const o=[];for(let t=0;t<this.constraints.length;t++){const n=this.constraints[t];n.v1=i[n.v1],n.v2=i[n.v2],Math.abs(n.v1-n.v2)<1e-9||o.push(n)}this.constraints=o,this.cutVertices=t,this.vertexAdjacency=n}volume(){let t=[];this.vertices.forEach((n=>{t.push(n.position.x,n.position.y,n.position.z)})),this.cutVertices.forEach((n=>{t.push(n.position.x,n.position.y,n.position.z)}));let n,i=t.length/3,e=[0,0,0],s=[0,0,0];for(;i--;)n=3*i,t[n]<e[0]?e[0]=t[n]:t[n]>s[0]&&(s[0]=t[n]),t[n+1]<e[1]?e[1]=t[n+1]:t[n+1]>s[1]&&(s[1]=t[n+1]),t[n+2]<e[2]?e[2]=t[n+2]:t[n+2]>s[2]&&(s[2]=t[n+2]);let o=[s[0]-e[0],s[1]-e[1],s[2]-e[2]];return.5*o[0]*8*(.5*o[1])*(.5*o[2])}calculateBounds(){if(!this.vertices.length)return;let t=this.vertices[0].position.clone(),n=t.clone();this.vertices.forEach((i=>{t.x=Math.min(t.x,i.position.x),t.y=Math.min(t.y,i.position.y),t.z=Math.min(t.z,i.position.z),n.x=Math.max(n.x,i.position.x),n.y=Math.max(n.y,i.position.y),n.z=Math.max(n.z,i.position.z)})),this.bounds=new i(t,n)}toMesh(n,i=null,o=!0,r=0){const a=new t,h=new t;let l=this.toGeometry(o,r);l.boundingBox.getCenter(a),l.boundingBox.getSize(h),l.translate(-a.x,-a.y,-a.z),l.boundingSphere=new e(new t,.5*h.length());let u=n.material;i&&u.isMaterial&&(u=[n.material,i]);const c=new s(l,u);return c.receiveShadow=n.receiveShadow,c.castShadow=n.castShadow,c.matrixAutoUpdate=n.matrixAutoUpdate,c.frustumCulled=n.frustumCulled,c.renderOrder=n.renderOrder,c.sizer=h.length(),a.applyQuaternion(n.quaternion),c.position.copy(n.position).add(a),c.quaternion.copy(n.quaternion),c.userData={origin:c.position.clone(),direction:a.normalize(),size:h},c}makeTrickness(t,n,i,e,s){let o,r=1-s,a=[...t],h=[...n],l=[...i],u=t.length/3,c=u;for(;c--;)o=3*c,a[o]*=r,a[o+1]*=r,a[o+2]*=r;let g=[];for(c=e.length;c--;)g[c]=e[c]+u;return[a,h,l,g]}toGeometry(t,n){let i;const e=new o;let s=[],a=[],h=[];if(this.vertices.forEach((t=>{s.push(t.position.x,t.position.y,t.position.z),a.push(t.normal.x,t.normal.y,t.normal.z),h.push(t.uv.x,t.uv.y)})),0!==n){let t=this.makeTrickness(s,a,h,this.triangles[0],n);s=s.concat(t[0]),a=a.concat(t[1]),h=h.concat(t[2]),i=t[3]}return t&&this.cutVertices.forEach((t=>{s.push(t.position.x,t.position.y,t.position.z),a.push(t.normal.x,t.normal.y,t.normal.z),h.push(t.uv.x,t.uv.y)})),e.addGroup(0,this.triangles[0].length,0),0!==n&&(e.addGroup(this.triangles[0].length,i.length,1),this.triangles[0]=this.triangles[0].concat(i)),t&&e.addGroup(this.triangles[0].length,this.triangles[1].length,1),e.setAttribute("position",new r(new Float32Array(s),3)),e.setAttribute("normal",new r(new Float32Array(a),3)),e.setAttribute("uv",new r(new Float32Array(h),2)),e.setIndex(new r(new Uint32Array(this.triangles.flat()),1)),e.computeBoundingBox(),e}isConvex(n=.001){this.convextested=!0;let i=0;const e=this.triangleCount,s=[...this.triangles[0],...this.triangles[1]],o=[...this.vertices,...this.cutVertices],r=o.length;if(0===e||0===r)return!1;const a=new t,h=new t,l=new t,u=new t,c=new t;let g,d;for(let t=0;t<e;t++){i=3*t,c.copy(o[0].position),a.copy(o[s[i]].position),h.copy(o[s[i+1]].position),l.copy(o[s[i+2]].position),h.sub(a),l.sub(a),u.copy(h).cross(l).normalize(),g=c.sub(a).dot(u);for(let t=0;t<r;t++)if(d=c.copy(o[t].position).sub(a).dot(u),Math.abs(g)>n&&Math.abs(d)>n&&g*d<0)return!1}return!0}}class T{constructor(t,n,i=-1,e=-1,s=0){this.v1=t,this.v2=n,this.t1=i,this.t2=e,this.t1Edge=s}clone(){return new T(this.v1,this.v2,this.t1,this.t2,this.t1Edge)}equals(t){return this.v1===t.v1&&this.v2===t.v2||this.v1===t.v2&&this.v2===t.v1}toString(){return`Edge: T${this.t1}->T${this.t2} (V${this.v1}->V${this.v2})`}}class S{static getBinNumber(t,n,i){return t%2==0?t*i+n:(t+1)*i-n-1}static sort(t,n,i){if(i<=1)return t;n>t.length&&(n=t.length);const e=new Array(i).fill(0),s=new Array(t.length);for(let i=0;i<n;i++)e[t[i].bin]++;for(let t=1;t<i;t++)e[t]+=e[t-1];for(let i=n-1;i>=0;i--){const n=t[i].bin;e[n]--,s[e[n]]=t[i]}for(let i=n;i<s.length;i++)s[i]=t[i];return s}}class E{constructor(t,n){this.index=t,this.coords=n,this.bin=0}toString(){return`${this.coords} -> ${this.bin}`}}const N=-1;class q{constructor(i,e){if(this.normalizationScaleFactor=1,this.N=i.length,this.N>=3){this.triangleCount=2*this.N+1,this.triangulation=Array.from({length:this.triangleCount},(()=>new Array(6).fill(0))),this.skipTriangle=new Array(this.triangleCount).fill(!1),this.points=new Array(this.N+3),this.normal=e.clone().normalize();let r=i[0].position.clone().sub(i[1].position).normalize(),a=this.normal.clone(),h=new t;h.crossVectors(r,a).normalize();for(let t=0;t<this.N;t++){var s=i[t].position,o=new n(s.dot(r),s.dot(h));this.points[t]=new E(t,o)}}else this.triangleCount=0,this.triangulation=[],this.skipTriangle=[],this.points=[],this.normal=new t}triangulate(){if(this.N<3)return[];this.addSuperTriangle(),this.normalizeCoordinates(),this.computeTriangulation(),this.discardTrianglesWithSuperTriangleVertices();const t=[];for(let n=0;n<this.triangleCount;n++)this.skipTriangle[n]||t.push(this.triangulation[n][0],this.triangulation[n][1],this.triangulation[n][2]);return t}normalizeCoordinates(){let t=Number.MAX_VALUE,i=Number.MIN_VALUE,e=Number.MAX_VALUE,s=Number.MIN_VALUE;for(let n=0;n<this.N;n++)t=Math.min(t,this.points[n].coords.x),i=Math.max(i,this.points[n].coords.x),e=Math.min(e,this.points[n].coords.y),s=Math.max(s,this.points[n].coords.y);const o=Math.max(i-t,s-e);for(let i=0;i<this.N;i++){var r=this.points[i],a=new n((r.coords.x-t)/o,(r.coords.y-e)/o);this.points[i].coords=a}}sortPointsIntoBins(){const t=Math.round(Math.pow(this.N,.25)),n=t*t;for(let n=0;n<this.N;n++){var i=this.points[n];const e=Math.floor(.99*t*i.coords.y),s=Math.floor(.99*t*i.coords.x);i.bin=S.getBinNumber(e,s,t)}return S.sort(this.points,this.N,n)}computeTriangulation(){let t=0,n=0,i=this.sortPointsIntoBins();for(let e=0;e<this.N;e++){let s=i[e];if(!s)break;let o=0,r=!1;for(;!r&&!(o++>n||t===N);){let i=this.points[this.triangulation[t][0]].coords,e=this.points[this.triangulation[t][1]].coords,o=this.points[this.triangulation[t][2]].coords;f(i,e,s.coords)?f(e,o,s.coords)?f(o,i,s.coords)?(this.insertPointIntoTriangle(s,t,n),n+=2,t=n,r=!0):t=this.triangulation[t][5]:t=this.triangulation[t][4]:t=this.triangulation[t][3]}}}addSuperTriangle(){this.points[this.N]=new E(this.N,new n(-100,-100)),this.points[this.N+1]=new E(this.N+1,new n(0,100)),this.points[this.N+2]=new E(this.N+2,new n(100,-100)),this.triangulation[0][0]=this.N,this.triangulation[0][1]=this.N+1,this.triangulation[0][2]=this.N+2,this.triangulation[0][3]=N,this.triangulation[0][4]=N,this.triangulation[0][5]=N}insertPointIntoTriangle(t,n,i){const e=n,s=i+1,o=i+2;this.triangulation[s][0]=t.index,this.triangulation[s][1]=this.triangulation[n][1],this.triangulation[s][2]=this.triangulation[n][2],this.triangulation[s][3]=o,this.triangulation[s][4]=this.triangulation[n][4],this.triangulation[s][5]=e,this.triangulation[o][0]=t.index,this.triangulation[o][1]=this.triangulation[n][0],this.triangulation[o][2]=this.triangulation[n][1],this.triangulation[o][3]=e,this.triangulation[o][4]=this.triangulation[n][3],this.triangulation[o][5]=s,this.updateAdjacency(this.triangulation[n][3],n,o),this.updateAdjacency(this.triangulation[n][4],n,s),this.triangulation[e][1]=this.triangulation[n][2],this.triangulation[e][2]=this.triangulation[n][0],this.triangulation[e][0]=t.index,this.triangulation[e][4]=this.triangulation[n][5],this.triangulation[e][3]=s,this.triangulation[e][5]=o,this.restoreDelauneyTriangulation(t,e,s,o)}restoreDelauneyTriangulation(t,n,i,e){const s=[];for(s.push([n,this.triangulation[n][4]]),s.push([i,this.triangulation[i][4]]),s.push([e,this.triangulation[e][4]]);s.length>0;)if([n,i]=s.pop()??[N,N],i!==N){const e=this.swapQuadDiagonalIfNeeded(t.index,n,i);null!==e&&(s.push([n,e.t3]),s.push([i,e.t4]))}}swapQuadDiagonalIfNeeded(t,n,i){let e=0,s=0,o=0,r=t,a=0,h=0;this.triangulation[i][3]===n?(e=this.triangulation[i][1],s=this.triangulation[i][0],o=this.triangulation[i][2],a=this.triangulation[i][4],h=this.triangulation[i][5]):this.triangulation[i][4]===n?(e=this.triangulation[i][2],s=this.triangulation[i][1],o=this.triangulation[i][0],a=this.triangulation[i][5],h=this.triangulation[i][3]):(e=this.triangulation[i][0],s=this.triangulation[i][2],o=this.triangulation[i][1],a=this.triangulation[i][3],h=this.triangulation[i][4]);return this.swapTest(this.points[e].coords,this.points[s].coords,this.points[o].coords,this.points[r].coords)?(this.updateAdjacency(a,i,n),this.updateAdjacency(this.triangulation[n][5],n,i),this.triangulation[n][0]=r,this.triangulation[n][1]=e,this.triangulation[n][2]=o,this.triangulation[i][0]=r,this.triangulation[i][1]=o,this.triangulation[i][2]=s,this.triangulation[i][3]=n,this.triangulation[i][4]=h,this.triangulation[i][5]=this.triangulation[n][5],this.triangulation[n][4]=a,this.triangulation[n][5]=i,{t3:a,t4:h}):null}discardTrianglesWithSuperTriangleVertices(){for(let t=0;t<this.triangleCount;t++)(this.triangleContainsVertex(t,this.N)||this.triangleContainsVertex(t,this.N+1)||this.triangleContainsVertex(t,this.N+2))&&(this.skipTriangle[t]=!0)}swapTest(t,n,i,e){const s=t.x-i.x,o=n.x-i.x,r=t.y-i.y,a=n.y-i.y,h=t.x-e.x,l=n.x-e.x,u=t.y-e.y,c=n.y-e.y,g=s*o+r*a,d=l*h+c*u;if(g>=0&&d>=0)return!1;if(g<0&&d<0)return!0;return(s*a-o*r)*d+(l*u-h*c)*g<0}triangleContainsVertex(t,n){return this.triangulation[t][0]===n||this.triangulation[t][1]===n||this.triangulation[t][2]===n}updateAdjacency(t,n,i){if(t===N)return;const e=this.findSharedEdge(t,n);e&&(this.triangulation[t][e]=i)}findSharedEdge(t,n){return t===N?null:this.triangulation[t][3]===n?3:this.triangulation[t][4]===n?4:this.triangulation[t][5]===n?5:null}}class P{constructor(t,n,i,e,s,o,r,a,h,l){this.q1=t,this.q2=n,this.q3=i,this.q4=e,this.t1=s,this.t2=o,this.t1L=r,this.t1R=a,this.t2L=h,this.t2R=l}toString(){return`T${this.t1}/T${this.t2} (V${this.q1},V${this.q2},V${this.q3},V${this.q4})`}}class F extends q{edgeVertex1=[0,0,0,0,1,2];edgeVertex2=[0,0,0,1,2,0];oppositePoint=[0,0,0,2,0,1];nextEdge=[0,0,0,4,5,3];previousEdge=[0,0,0,5,3,4];constructor(t,n,i){super(t,i),this.constraints=n,this.vertexTriangles=[]}triangulate(){if(this.N<3)return[];this.addSuperTriangle(),this.normalizeCoordinates(),this.computeTriangulation(),this.constraints.length>0&&(this.applyConstraints(),this.discardTrianglesViolatingConstraints()),this.discardTrianglesWithSuperTriangleVertices();let t=[];for(let n=0;n<this.triangleCount;n++)this.skipTriangle[n]||(t.push(this.triangulation[n][0]),t.push(this.triangulation[n][1]),t.push(this.triangulation[n][2]));return t}applyConstraints(){const t=this.triangulation.length;this.vertexTriangles=new Array(this.N+3).fill(0);for(let n=0;n<t;n++)this.vertexTriangles[this.triangulation[n][0]]=n,this.vertexTriangles[this.triangulation[n][1]]=n,this.vertexTriangles[this.triangulation[n][2]]=n;for(let t of this.constraints){if(t.v1===t.v2)continue;const n=this.findIntersectingEdges(t,this.vertexTriangles);this.removeIntersectingEdges(t,n)}}findIntersectingEdges(t,n){const i=[],e=this.findStartingEdge(n,t);if(null===e)return i;i.push(e);let s=e.t1,o=e.t1Edge,r=s,a=!1;for(;!a;){r=s,s=this.triangulation[s][o];const n=this.points[t.v1].coords,e=this.points[t.v2].coords,h=this.points[this.triangulation[s][0]].coords,l=this.points[this.triangulation[s][1]].coords,u=this.points[this.triangulation[s][2]].coords;if(this.triangleContainsVertex(s,t.v2))a=!0;else if(this.triangulation[s][3]!==r&&x(n,e,h,l)){o=3;const t=new T(this.triangulation[s][0],this.triangulation[s][1],s,this.triangulation[s][3],o);i.push(t)}else if(this.triangulation[s][4]!==r&&x(n,e,l,u)){o=4;const t=new T(this.triangulation[s][1],this.triangulation[s][2],s,this.triangulation[s][4],o);i.push(t)}else{if(this.triangulation[s][5]===r||!x(n,e,u,h)){console.warn("Failed to find final triangle, exiting early.");break}{o=5;const t=new T(this.triangulation[s][2],this.triangulation[s][0],s,this.triangulation[s][5],o);i.push(t)}}}return i}findStartingEdge(t,n){let i,e,s,o=new T(-1,-1),r=n.v1,a=t[r],h=!1,l=null;const u=new Array(this.triangulation.length);for(;!l&&!h;){if(u[a]=!0,this.triangleContainsConstraint(a,n))return null;if(l=this.edgeConstraintIntersectsTriangle(a,n),l)break;if(i=this.triangulation[a][3],e=this.triangulation[a][4],s=this.triangulation[a][5],-1!==i&&!u[i]&&this.triangleContainsVertex(i,r))a=i;else if(-1!==e&&!u[e]&&this.triangleContainsVertex(e,r))a=e;else{if(-1===s||u[s]||!this.triangleContainsVertex(s,r)){h=!0;break}a=s}}if(l){const t=this.triangulation[a][this.edgeVertex1[l]],n=this.triangulation[a][this.edgeVertex2[l]],i=this.triangulation[a][l];return o=new T(t,n,a,i,l),o}return null}removeIntersectingEdges(t,n){let i,e=[],s=0;for(;n.length>0&&s<=n.length;){i=n.shift(),null==i&&console.log("no edge !!");let o=this.findQuadFromSharedEdge(i.t1,i.t1Edge);if(o)if(x(this.points[o.q4].coords,this.points[o.q3].coords,this.points[o.q1].coords,this.points[o.q2].coords)){this.swapQuadDiagonal(o,n,e,this.constraints);let i=new T(o.q3,o.q4,o.t1,o.t2,5);x(this.points[t.v1].coords,this.points[t.v2].coords,this.points[o.q3].coords,this.points[o.q4].coords)?n.push(i):(s=0,e.push(i))}else n.push(i);s++}e.length>0&&this.restoreConstrainedDelauneyTriangulation(t,e)}restoreConstrainedDelauneyTriangulation(t,n){let i=!0;for(;i;){i=!1;for(let e=0;e<n.length;e++){const s=n[e];if(s.equals(t))continue;let o=this.findQuadFromSharedEdge(s.t1,s.t1Edge);if(o&&this.swapTest(this.points[o.q1].coords,this.points[o.q2].coords,this.points[o.q3].coords,this.points[o.q4].coords)){this.swapQuadDiagonal(o,n,this.constraints,null);const t=o.q3,s=o.q4;n[e]=new T(t,s,o.t1,o.t2,5),i=!0}}}}discardTrianglesViolatingConstraints(){this.skipTriangle.fill(!0);let t=new Set;for(let n=0;n<this.constraints.length;n++){const i=this.constraints[n];t.add(v(i.v1,i.v2))}let n,i,e,s,o,r,a,h,l,u=[];const c=new Array(this.triangulation.length);for(let g=0;g<this.triangleCount;g++)if(!c[g]&&(n=this.triangulation[g][0],i=this.triangulation[g][1],e=this.triangulation[g][2],s=t.has(v(n,i)),o=t.has(v(i,e)),r=t.has(v(e,n)),a=t.has(v(i,n)),h=t.has(v(e,i)),l=t.has(v(n,e)),!(a||h||l)&&(s||o||r)))for(this.skipTriangle[g]=!1,u=[],s||u.push(this.triangulation[g][3]),o||u.push(this.triangulation[g][4]),r||u.push(this.triangulation[g][5]);u.length>0;){const s=u.shift();void 0===s||-1===s||c[s]||(n=this.triangulation[s][0],i=this.triangulation[s][1],e=this.triangulation[s][2],a=t.has(v(i,n)),h=t.has(v(e,i)),l=t.has(v(n,e)),a||h||l?c[s]=!0:(this.skipTriangle[s]=!1,c[s]=!0,t.has(v(n,i))||u.push(this.triangulation[s][3]),t.has(v(i,e))||u.push(this.triangulation[s][4]),t.has(v(e,n))||u.push(this.triangulation[s][5])))}}triangleContainsConstraint(t,n){return!(t>=this.triangulation.length)&&!(this.triangulation[t][0]!==n.v1&&this.triangulation[t][1]!==n.v1&&this.triangulation[t][2]!==n.v1||this.triangulation[t][0]!==n.v2&&this.triangulation[t][1]!==n.v2&&this.triangulation[t][2]!==n.v2)}edgeConstraintIntersectsTriangle(t,n){const i=this.points[n.v1].coords,e=this.points[n.v2].coords,s=this.points[this.triangulation[t][0]].coords,o=this.points[this.triangulation[t][1]].coords,r=this.points[this.triangulation[t][2]].coords;return x(i,e,s,o)?3:x(i,e,o,r)?4:x(i,e,r,s)?5:null}findQuadFromSharedEdge(t,n){let i,e,s,o,r,a,h,l,u=this.triangulation[t][n],c=this.findSharedEdge(u,t);return c?(3===c?(e=this.triangulation[u][0],i=this.triangulation[u][1],s=this.triangulation[u][2]):4===c?(e=this.triangulation[u][1],i=this.triangulation[u][2],s=this.triangulation[u][0]):(e=this.triangulation[u][2],i=this.triangulation[u][0],s=this.triangulation[u][1]),o=this.triangulation[t][this.oppositePoint[n]],r=this.triangulation[t][this.previousEdge[n]],a=this.triangulation[t][this.nextEdge[n]],h=this.triangulation[u][this.nextEdge[c]],l=this.triangulation[u][this.previousEdge[c]],new P(i,e,s,o,t,u,r,a,h,l)):null}swapQuadDiagonal(t,n,i,e){const s=t.t1,o=t.t2,r=t.t1R,a=t.t1L,h=t.t2R,l=t.t2L;this.triangulation[s][0]=t.q4,this.triangulation[s][1]=t.q1,this.triangulation[s][2]=t.q3,this.triangulation[o][0]=t.q4,this.triangulation[o][1]=t.q3,this.triangulation[o][2]=t.q2,this.triangulation[s][3]=a,this.triangulation[s][4]=l,this.triangulation[s][5]=o,this.triangulation[o][3]=s,this.triangulation[o][4]=h,this.triangulation[o][5]=r,this.updateAdjacency(l,o,s),this.updateAdjacency(r,s,o),this.updateEdgesAfterSwap(n,s,o,a,r,l,h),this.updateEdgesAfterSwap(i,s,o,a,r,l,h),this.updateEdgesAfterSwap(e,s,o,a,r,l,h),this.vertexTriangles[t.q1]=s,this.vertexTriangles[t.q2]=o}updateEdgesAfterSwap(t,n,i,e,s,o,r){if(t)for(let a of t)a.t1===n&&a.t2===s?(a.t1=i,a.t2=s,a.t1Edge=5):a.t1===n&&a.t2===e?a.t1Edge=3:a.t1===s&&a.t2===n?a.t2=i:a.t1===e&&a.t2===n||(a.t1===i&&a.t2===r?a.t1Edge=4:a.t1===i&&a.t2===o?(a.t1=n,a.t2=o,a.t1Edge=4):a.t1===r&&a.t2===i||a.t1===o&&a.t2===i&&(a.t2=n))}}function I(t,i,e,s,o,r=!1,a=!0){const h=new C,l=new C,u=new Array(t.vertexCount).fill(!1);for(let n=0;n<t.vertices.length;n++){const s=t.vertices[n];u[n]=z(s.position,i,e);(u[n]?h:l).addMappedVertex(s,n)}const c=t.vertices.length;for(let n=0;n<t.cutVertices.length;n++){const s=t.cutVertices[n];u[n+c]=z(s.position,i,e);(u[n+c]?h:l).addMappedVertex(s,n+c)}return k(t,h,l,i,e,u,V),a&&k(t,h,l,i,e,u,A),a&&function(t,i,e,s,o,r){if(t.weldCutFaceVertices(),i.weldCutFaceVertices(),t.cutVertices.length<3)return;const a=r?new q(t.cutVertices,e):new F(t.cutVertices,t.constraints,e),h=a.triangulate();for(let r=0;r<t.cutVertices.length;r++){var l=t.cutVertices[r],u=a.points[r];const h=new n(a.normalizationScaleFactor*u.coords.x*s.x+o.x,a.normalizationScaleFactor*u.coords.y*s.y+o.y),c=new b(l.position.clone(),e.clone(),h.clone()),g=new b(l.position.clone(),e.clone().negate(),h.clone());t.cutVertices[r]=c,i.cutVertices[r]=g}let c=t.vertices.length,g=i.vertices.length;for(let n=0;n<h.length;n+=3)t.addTriangle(c+h[n],c+h[n+1],c+h[n+2],A),i.addTriangle(g+h[n],g+h[n+2],g+h[n+1],A)}(h,l,i.clone().negate(),s,o,r),{topSlice:h,bottomSlice:l}}function k(t,n,i,e,s,o,r){const a=t.triangles[r];let h,l,u;for(let c=0;c<a.length;c+=3)h=a[c],l=a[c+1],u=a[c+2],o[h]&&o[l]&&o[u]?n.addMappedTriangle(h,l,u,r):o[h]||o[l]||o[u]?o[l]&&o[u]&&!o[h]?j(l,u,h,e,s,t,n,i,r,!0):o[u]&&o[h]&&!o[l]?j(u,h,l,e,s,t,n,i,r,!0):o[h]&&o[l]&&!o[u]?j(h,l,u,e,s,t,n,i,r,!0):o[l]||o[u]||!o[h]?o[u]||o[h]||!o[l]?o[h]||o[l]||!o[u]||j(h,l,u,e,s,t,n,i,r,!1):j(u,h,l,e,s,t,n,i,r,!1):j(l,u,h,e,s,t,n,i,r,!1):i.addMappedTriangle(h,l,u,r)}function j(i,e,s,o,r,a,h,l,u,c){const g=a.vertices.length;let d=i<g?a.vertices[i]:a.cutVertices[i-g],p=e<g?a.vertices[e]:a.cutVertices[e-g],x=s<g?a.vertices[s]:a.cutVertices[s-g];const f=m(d.position,x.position,o,r),y=m(p.position,x.position,o,r);if(f&&y){const o=new t(d.normal.x+f.s*(x.normal.x-d.normal.x),d.normal.y+f.s*(x.normal.y-d.normal.y),d.normal.z+f.s*(x.normal.z-d.normal.z)).normalize(),r=new t(p.normal.x+y.s*(x.normal.x-p.normal.x),p.normal.y+y.s*(x.normal.y-p.normal.y),p.normal.z+y.s*(x.normal.z-p.normal.z)).normalize(),a=new n(d.uv.x+f.s*(x.uv.x-d.uv.x),d.uv.y+f.s*(x.uv.y-d.uv.y)),g=new n(p.uv.x+y.s*(x.uv.x-p.uv.x),p.uv.y+y.s*(x.uv.y-p.uv.y));h.addCutFaceVertex(f.x,o,a),h.addCutFaceVertex(y.x,r,g),l.addCutFaceVertex(f.x,o,a),l.addCutFaceVertex(y.x,r,g);const m=h.vertices.length,v=l.vertices.length,w=h.cutVertices.length,M=l.cutVertices.length,z=m-2,b=m-1,V=v-2,A=v-1;c?(h.addTriangle(b,z,h.indexMap[e],u),h.addTriangle(z,h.indexMap[i],h.indexMap[e],u),l.addTriangle(l.indexMap[s],V,A,u),h.constraints.push(new T(w-2,w-1)),l.constraints.push(new T(M-1,M-2))):(h.addTriangle(z,b,h.indexMap[s],u),l.addTriangle(l.indexMap[i],l.indexMap[e],V,u),l.addTriangle(l.indexMap[e],A,V,u),h.constraints.push(new T(w-1,w-2)),l.constraints.push(new T(M-2,M-1)))}}function B(n,i,e,s,o,r,a){let h=n;const l=e[i],u=s||function(t,n){const i=[];for(let e=0;e<n;e++)e!==t&&i.push(e);return i}(i,e.length);for(const n of u){const i=e[n],s=(g=i,{origin:new t(((c=l).x+g.x)/2,(c.y+g.y)/2,(c.z+g.z)/2),normal:new t(g.x-c.x,g.y-c.y,g.z-c.z).normalize()}),{bottomSlice:u}=I(h,s.normal,s.origin,o,r,a);if(h=u,0===h.vertexCount)return null}var c,g;return h}function $(t,n,i){const e=n[t],s=[];for(let i=0;i<n.length;i++){if(i===t)continue;const o=n[i].x-e.x,r=n[i].y-e.y,a=n[i].z-e.z,h=Math.sqrt(o*o+r*r+a*a);s.push({index:i,distance:h})}return s.sort(((t,n)=>t.distance-n.distance)),s.slice(0,Math.min(i,s.length)).map((t=>t.index))}function D(i){const e=i.attributes.position.array,s=i.attributes.normal.array,o=i.attributes.uv?.array,r=new C,a=i.attributes.position.count;let h,l,u;for(let i=0;i<a;i++){h=3*i,l=2*i;const a=new t(e[h],e[h+1],e[h+2]),u=new t(s[h],s[h+1],s[h+2]),c=o?new n(o[l],o[l+1]):new n(0,0);r.vertices.push(new b(a,u,c))}if(i.index)u=Array.from(i.index.array);else{const t=e.length/3;u=Array.from({length:t},((t,n)=>n))}if(i.groups&&2===i.groups.length){const t=[],n=[];for(const e of i.groups){const i=0===e.materialIndex?t:n,s=e.start,o=s+e.count;for(let t=s;t<o;t++)i.push(u[t])}r.triangles=[t,n]}else r.triangles=[u,[]];return r.calculateBounds(),r}class O{constructor(t){this.parent=[],this.rank=[];for(let n=0;n<t;n++)this.parent[n]=n,this.rank[n]=1}find(t){return this.parent[t]!==t&&(this.parent[t]=this.find(this.parent[t])),this.parent[t]}union(t,n){const i=this.find(t),e=this.find(n);i!==e&&(this.rank[i]>this.rank[e]?this.parent[e]=i:this.rank[i]<this.rank[e]?this.parent[i]=e:(this.parent[e]=i,this.rank[i]+=1))}}function U(t){const n=new O(t.vertexCount),i={},e=t.vertices.length,s=t.cutVertices.length,o=new Map;t.vertices.forEach(((t,i)=>{const e=M(t.position),s=o.get(e);void 0===s?o.set(e,i):n.union(s,i)}));for(let i=0;i<s;i++)n.union(t.vertexAdjacency[i],i+e);const r=t.triangles;for(let t=0;t<r.length;t++)for(let e=0;e<r[t].length;e+=3){const s=r[t][e],o=r[t][e+1],a=r[t][e+2];n.union(s,o),n.union(o,a);const h=n.find(s);i[h]||(i[h]=[[],[]]),i[h][t].push(s,o,a)}const a={},h=Array(t.vertexCount);for(let i=0;i<e;i++){const e=n.find(i);a[e]||(a[e]=new C),a[e].vertices.push(t.vertices[i]),h[i]=a[e].vertices.length-1}for(let i=0;i<s;i++){const s=n.find(i+e);a[s].cutVertices.push(t.cutVertices[i]),h[i+e]=a[s].vertices.length+a[s].cutVertices.length-1}for(const e of Object.keys(i)){let s=Number(e),o=n.parent[s];for(let n=0;n<t.triangles.length;n++)for(const t of i[s][n]){const i=h[t];a[o].triangles[n].push(i)}}return Object.values(a)}function L(t,n){const i=new l(n.seed),e=i.getSeed();void 0===n.seed&&(n.seed=e);const s=D(t);let a;return a="3D"===n.mode?function(t,n,i){const e=function(t,n,i){if(n.seedPoints&&n.seedPoints.length>0)return n.seedPoints;t.bounds||t.calculateBounds();if(n.impactPoint){const e=n.impactRadius||.3*Math.min(t.bounds.max.x-t.bounds.min.x,t.bounds.max.y-t.bounds.min.y,t.bounds.max.z-t.bounds.min.z);return h.generateImpactBased(t.bounds,n.fragmentCount,n.impactPoint,e,i)}return h.generateUniform(t.bounds,n.fragmentCount,i)}(t,n,i),s=[],o=!1,r=n.useApproximation,a=Math.min(n.approximationNeighborCount,e.length-1);r&&console.warn(`⚠️ Voronoi approximation enabled (k=${a} neighbors). This may cause fragment overlaps.`,"\nFor accurate results with no overlaps, set useApproximation: false in VoronoiFractureOptions.");for(let i=0;i<e.length;i++){const h=B(Q(t),i,e,r?$(i,e,a):null,n.textureScale,n.textureOffset,o);if(h&&h.vertexCount>0){const t=U(h);s.push(...t)}}return s}(s,n,i):function(t,n,i){let e,s;if(t.calculateBounds(),n.projectionNormal){const t=n.projectionNormal,i=Math.abs(t.x),s=Math.abs(t.y),o=Math.abs(t.z);e=i>s&&i>o?"x":s>i&&s>o?"y":"z"}else{const i=n.projectionAxis||"auto";e="auto"===i?h.determineBestProjectionAxis(t.bounds):i}if(n.seedPoints)s=n.seedPoints;else if(n.impactPoint){const o=n.impactRadius||.3*Math.min(t.bounds.max.x-t.bounds.min.x,t.bounds.max.y-t.bounds.min.y,t.bounds.max.z-t.bounds.min.z);s=h.generate2DImpactBased(t.bounds,n.fragmentCount,n.impactPoint,o,e,i)}else s=h.generate2D(t.bounds,n.fragmentCount,e,i);const o=[],r=!1,a=n.useApproximation,l=Math.min(n.approximationNeighborCount,s.length-1);a&&console.warn(`⚠️ Voronoi 2.5D approximation enabled (k=${l} neighbors). This may cause fragment overlaps.`,"\nFor accurate results with no overlaps, set useApproximation: false in VoronoiFractureOptions.");for(let i=0;i<s.length;i++){const e=B(Q(t),i,s,a?$(i,s,l):null,n.textureScale,n.textureOffset,r);if(e&&e.vertexCount>0){const t=U(e);o.push(...t)}}return o}(s,n,i),a.map((t=>function(t){const n=new o,i=t.vertices.length+t.cutVertices.length,e=new Array(3*i),s=new Array(3*i),a=new Array(2*i);let h=0,l=0,u=0;for(const n of t.vertices)e[h++]=n.position.x,e[h++]=n.position.y,e[h++]=n.position.z,s[l++]=n.normal.x,s[l++]=n.normal.y,s[l++]=n.normal.z,a[u++]=n.uv.x,a[u++]=n.uv.y;for(const n of t.cutVertices)e[h++]=n.position.x,e[h++]=n.position.y,e[h++]=n.position.z,s[l++]=n.normal.x,s[l++]=n.normal.y,s[l++]=n.normal.z,a[u++]=n.uv.x,a[u++]=n.uv.y;return n.addGroup(0,t.triangles[0].length,0),n.addGroup(t.triangles[0].length,t.triangles[1].length,1),n.setAttribute("position",new r(new Float32Array(e),3)),n.setAttribute("normal",new r(new Float32Array(s),3)),n.setAttribute("uv",new r(new Float32Array(a),2)),n.setIndex(new r(new Uint32Array(t.triangles.flat()),1)),n}(t)))}function Q(t){const n=new C;return n.vertices=t.vertices.map((t=>t.clone())),n.cutVertices=t.cutVertices.map((t=>t.clone())),n.triangles=t.triangles.map((t=>[...t])),n.constraints=t.constraints.map((t=>t.clone())),n.vertexAdjacency=[...t.vertexAdjacency],n.indexMap={...t.indexMap},t.bounds&&(n.bounds=t.bounds.clone()),n}const R={fragmentCount:50,fracturePlanes:{x:!0,y:!0,z:!0},fractureMode:"Convex",textureScale:new n(1,1),textureOffset:new n,intern:!0};function G(t,n,i,e,s=25,o){const r=t.matrixWorld.clone().invert();t.position;const a=t.geometry;n.applyMatrix4(r);return L(a,{fragmentCount:s,mode:options.voronoiOptions.mode,impactPoint:n,impactRadius:options.voronoiOptions.impactRadius,projectionAxis:"auto",projectionNormal:i,useApproximation:!1,approximationNeighborCount:12})}const W=new t,_=new t,X=new t,H=new a,J=new a;function K(n,i,e,s,o,r){const a=[],h=n.matrixWorld.clone().invert(),l=n.position;i.applyMatrix4(h);const u=D(n.geometry);let c=u.convex,g=.03*u.volume();W.addVectors(i,e),H.setFromCoplanarPoints(i,l,W);const d=o+s;return function n(o,u,p,x){if(!o)return;if(Math.random()<.05*x||x>d)return void(o.valid&&a.push(o));let m=Math.PI,f=new t;o.calculateBounds(),o.bounds.getCenter(f);let y=c;if(0===x)J.normal.copy(H.normal),J.constant=H.constant;else if(x<=s)m=(p-u)*(.2+.6*Math.random())+u,_.copy(l).sub(i).applyAxisAngle(e,m).add(i),J.setFromCoplanarPoints(i,W,_);else{let t=f.clone().applyMatrix4(h);m=(.5*(1&x)+.2*(2-Math.random()))*Math.PI,_.copy(i).sub(t).applyAxisAngle(e,m).add(t),X.copy(e).add(t),J.setFromCoplanarPoints(t,X,_)}const{topSlice:v,bottomSlice:w}=I(o,J.normal,_,R.textureScale,R.textureOffset,y,r);let M=v,z=w;M=U(v),z=U(w),M&&(M.isFragment&&(M=[M]),M=Y(M,g),M.length>0&&M.forEach(((t,i)=>{0===i?n(t,m,p,x+1):a.push(t)}))),z&&(z.isFragment&&(z=[z]),z=Y(z,g),z.length>0&&z.forEach(((t,i)=>{0===i?n(t,m,p,x+1):a.push(t)})))}(u,0,2*Math.PI,0),a}function Y(t,n){if(0===t.length)return[];let i=0,e=-1,s=[];return t.forEach(((t,s)=>{t.minSize=n,t.bounds=null;let o=.5*t.size.length();t.valid&&o>0?o>i&&(i=o,e=s):t.good=!1})),-1!==e&&s.push(t[e]),t.forEach(((t,n)=>{t.good&&n!==e&&s.push(t)})),s}function Z(n,i){const e={...R,...i};let s=e.fragmentCount||2;const o=D(n.geometry);let r=o.convex;console.log("This Mesh is",r?"Convex":"Concave");const a=[o];for(;a.length<s;){const n=a.shift();if(0===n.vertexCount)continue;if(!n)continue;let i=new t(e.fracturePlanes.x?2*Math.random()-1:0,e.fracturePlanes.y?2*Math.random()-1:0,e.fracturePlanes.z?2*Math.random()-1:0).normalize(),s=new t;if(n.calculateBounds(),n.bounds.getCenter(s),r){const{topSlice:t,bottomSlice:o}=I(n,i,s,e.textureScale,e.textureOffset,!0,e.intern);a.push(t),a.push(o)}else{const{topSlice:t,bottomSlice:o}=I(n,i,s,e.textureScale,e.textureOffset,!1,e.intern),r=U(t),h=U(o);a.push(...r),a.push(...h)}}return a}function tt(t,n,i,e=!0,s=0){const o=[];return t.map(((t,r)=>{o.push(t.toMesh(n,i,e,s))})),o}export{Z as Fracture,tt as FragmentsToMesh,K as SubdivideByImpact,R as option,G as voronoiImpact};
