import{Vector3 as t,Vector2 as e,Plane as n,Line3 as r,Box3 as o,Mesh as s,BatchedMesh as i,Triangle as a,Sphere as c,Matrix4 as l,Ray as u,REVISION as f,BufferAttribute as d,FrontSide as p,BackSide as h,DoubleSide as y}from"three";const g=1.25,x=65535,m=Math.pow(2,-24),w=Symbol("SKIP_GENERATION");function B(t){return function(t){return t.index?t.index.count:t.attributes.position.count}(t)/3}function b(t,e){if(!t.index){const n=t.attributes.position.count,r=function(t,e=ArrayBuffer){return t>65535?new Uint32Array(new e(4*t)):new Uint16Array(new e(2*t))}(n,e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer);t.setIndex(new d(r,1));for(let t=0;t<n;t++)r[t]=t}}function A(t,e){const n=B(t),r=e||t.drawRange,o=r.start/3,s=(r.start+r.count)/3,i=Math.max(0,o),a=Math.min(n,s)-i;return[{offset:Math.floor(i),count:Math.floor(a)}]}function T(t,e){if(!t.groups||!t.groups.length)return A(t,e);const n=[],r=new Set,o=e||t.drawRange,s=o.start/3,i=(o.start+o.count)/3;for(const e of t.groups){const t=e.start/3,n=(e.start+e.count)/3;r.add(Math.max(s,t)),r.add(Math.min(i,n))}const a=Array.from(r.values()).sort(((t,e)=>t-e));for(let t=0;t<a.length-1;t++){const e=a[t],r=a[t+1];n.push({offset:Math.floor(e),count:Math.floor(r-e)})}return n}function P(t,e,n,r,o){let s=1/0,i=1/0,a=1/0,c=-1/0,l=-1/0,u=-1/0,f=1/0,d=1/0,p=1/0,h=-1/0,y=-1/0,g=-1/0;for(let r=6*e,o=6*(e+n);r<o;r+=6){const e=t[r+0],n=t[r+1],o=e-n,x=e+n;o<s&&(s=o),x>c&&(c=x),e<f&&(f=e),e>h&&(h=e);const m=t[r+2],w=t[r+3],B=m-w,b=m+w;B<i&&(i=B),b>l&&(l=b),m<d&&(d=m),m>y&&(y=m);const A=t[r+4],T=t[r+5],P=A-T,v=A+T;P<a&&(a=P),v>u&&(u=v),A<p&&(p=A),A>g&&(g=A)}r[0]=s,r[1]=i,r[2]=a,r[3]=c,r[4]=l,r[5]=u,o[0]=f,o[1]=d,o[2]=p,o[3]=h,o[4]=y,o[5]=g}function v(t,e,n){return n.min.x=e[t],n.min.y=e[t+1],n.min.z=e[t+2],n.max.x=e[t+3],n.max.y=e[t+4],n.max.z=e[t+5],n}function M(t){let e=-1,n=-1/0;for(let r=0;r<3;r++){const o=t[r+3]-t[r];o>n&&(n=o,e=r)}return e}function U(t,e){e.set(t)}function S(t,e,n){let r,o;for(let s=0;s<3;s++){const i=s+3;r=t[s],o=e[s],n[s]=r<o?r:o,r=t[i],o=e[i],n[i]=r>o?r:o}}function I(t,e,n){for(let r=0;r<3;r++){const o=e[t+2*r],s=e[t+2*r+1],i=o-s,a=o+s;i<n[r]&&(n[r]=i),a>n[r+3]&&(n[r+3]=a)}}function _(t){const e=t[3]-t[0],n=t[4]-t[1],r=t[5]-t[2];return 2*(e*n+n*r+r*e)}const F=32,z=(t,e)=>t.candidate-e.candidate,V=new Array(F).fill().map((()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0}))),q=new Float32Array(6);class C{constructor(){this.boundingData=new Float32Array(6)}}function E(t,e,n,r,o,s){let i=r,a=r+o-1;const c=s.pos,l=2*s.axis;for(;;){for(;i<=a&&n[6*i+l]<c;)i++;for(;i<=a&&n[6*a+l]>=c;)a--;if(!(i<a))return i;for(let t=0;t<3;t++){let n=e[3*i+t];e[3*i+t]=e[3*a+t],e[3*a+t]=n}for(let t=0;t<6;t++){let e=n[6*i+t];n[6*i+t]=n[6*a+t],n[6*a+t]=e}i++,a--}}function R(t,e,n,r,o,s){let i=r,a=r+o-1;const c=s.pos,l=2*s.axis;for(;;){for(;i<=a&&n[6*i+l]<c;)i++;for(;i<=a&&n[6*a+l]>=c;)a--;if(!(i<a))return i;{let e=t[i];t[i]=t[a],t[a]=e;for(let t=0;t<6;t++){let e=n[6*i+t];n[6*i+t]=n[6*a+t],n[6*a+t]=e}i++,a--}}}function X(t,e){return 65535===e[t+15]}function H(t,e){return e[t+6]}function N(t,e){return e[t+14]}function O(t){return t+8}function D(t,e){return e[t+6]}function L(t,e){return e[t+7]}let k,Y,Z,G;const W=Math.pow(2,32);function j(t){return"count"in t?1:1+j(t.left)+j(t.right)}function $(t,e,n){return k=new Float32Array(n),Y=new Uint32Array(n),Z=new Uint16Array(n),G=new Uint8Array(n),K(t,e)}function K(t,e){const n=t/4,r=t/2,o="count"in e,s=e.boundingData;for(let t=0;t<6;t++)k[n+t]=s[t];if(o){if(e.buffer){const r=e.buffer;G.set(new Uint8Array(r),t);for(let e=t,o=t+r.byteLength;e<o;e+=32){X(e/2,Z)||(Y[e/4+6]+=n)}return t+r.byteLength}{const o=e.offset,s=e.count;return Y[n+6]=o,Z[r+14]=s,Z[r+15]=x,t+32}}{const r=e.left,o=e.right,s=e.splitAxis;let i;if(i=K(t+32,r),i/4>W)throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return Y[n+6]=i/4,i=K(i,o),Y[n+7]=s,i}}function J(t,e,n,r,o){const{maxDepth:s,verbose:i,maxLeafTris:a,strategy:c,onProgress:l,indirect:u}=o,f=t._indirectBuffer,d=t.geometry,p=d.index?d.index.array:null,h=u?R:E,y=B(d),x=new Float32Array(6);let m=!1;const w=new C;return P(e,n,r,w.boundingData,x),function t(n,r,o,l=null,u=0){!m&&u>=s&&(m=!0,i&&(console.warn(`MeshBVH: Max depth of ${s} reached when generating BVH. Consider increasing maxDepth.`),console.warn(d)));if(o<=a||u>=s)return b(r+o),n.offset=r,n.count=o,n;const y=function(t,e,n,r,o,s){let i=-1,a=0;if(0===s)i=M(e),-1!==i&&(a=(e[i]+e[i+3])/2);else if(1===s)i=M(t),-1!==i&&(a=function(t,e,n,r){let o=0;for(let s=e,i=e+n;s<i;s++)o+=t[6*s+2*r];return o/n}(n,r,o,i));else if(2===s){const s=_(t);let c=g*o;const l=6*r,u=6*(r+o);for(let t=0;t<3;t++){const r=e[t],f=(e[t+3]-r)/F;if(o<8){const e=[...V];e.length=o;let r=0;for(let o=l;o<u;o+=6,r++){const s=e[r];s.candidate=n[o+2*t],s.count=0;const{bounds:i,leftCacheBounds:a,rightCacheBounds:c}=s;for(let t=0;t<3;t++)c[t]=1/0,c[t+3]=-1/0,a[t]=1/0,a[t+3]=-1/0,i[t]=1/0,i[t+3]=-1/0;I(o,n,i)}e.sort(z);let f=o;for(let t=0;t<f;t++){const n=e[t];for(;t+1<f&&e[t+1].candidate===n.candidate;)e.splice(t+1,1),f--}for(let r=l;r<u;r+=6){const o=n[r+2*t];for(let t=0;t<f;t++){const s=e[t];o>=s.candidate?I(r,n,s.rightCacheBounds):(I(r,n,s.leftCacheBounds),s.count++)}}for(let n=0;n<f;n++){const r=e[n],l=r.count,u=o-r.count,f=r.leftCacheBounds,d=r.rightCacheBounds;let p=0;0!==l&&(p=_(f)/s);let h=0;0!==u&&(h=_(d)/s);const y=1+g*(p*l+h*u);y<c&&(i=t,c=y,a=r.candidate)}}else{for(let t=0;t<F;t++){const e=V[t];e.count=0,e.candidate=r+f+t*f;const n=e.bounds;for(let t=0;t<3;t++)n[t]=1/0,n[t+3]=-1/0}for(let e=l;e<u;e+=6){let o=~~((n[e+2*t]-r)/f);o>=F&&(o=31);const s=V[o];s.count++,I(e,n,s.bounds)}const e=V[31];U(e.bounds,e.rightCacheBounds);for(let t=30;t>=0;t--){const e=V[t],n=V[t+1];S(e.bounds,n.rightCacheBounds,e.rightCacheBounds)}let d=0;for(let e=0;e<31;e++){const n=V[e],r=n.count,l=n.bounds,u=V[e+1].rightCacheBounds;0!==r&&(0===d?U(l,q):S(l,q,q)),d+=r;let f=0,p=0;0!==d&&(f=_(q)/s);const h=o-d;0!==h&&(p=_(u)/s);const y=1+g*(f*d+p*h);y<c&&(i=t,c=y,a=n.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${s} used.`);return{axis:i,pos:a}}(n.boundingData,l,e,r,o,c);if(-1===y.axis)return b(r+o),n.offset=r,n.count=o,n;const w=h(f,p,e,r,o,y);if(w===r||w===r+o)b(r+o),n.offset=r,n.count=o;else{n.splitAxis=y.axis;const s=new C,i=r,a=w-r;n.left=s,P(e,i,a,s.boundingData,x),t(s,i,a,x,u+1);const c=new C,l=w,f=o-a;n.right=c,P(e,l,f,c.boundingData,x),t(c,l,f,x,u+1)}return n}(w,n,r,x),w;function b(t){l&&l(t/y)}}function Q(t,e){const n=t.geometry;e.indirect&&(t._indirectBuffer=function(t,e){const n=(t.index?t.index.count:t.attributes.position.count)/3,r=n>65536,o=r?4:2,s=e?new SharedArrayBuffer(n*o):new ArrayBuffer(n*o),i=r?new Uint32Array(s):new Uint16Array(s);for(let t=0,e=i.length;t<e;t++)i[t]=t;return i}(n,e.useSharedArrayBuffer),function(t,e){const n=B(t),r=T(t,e).sort(((t,e)=>t.offset-e.offset)),o=r[r.length-1];o.count=Math.min(n-o.offset,o.count);let s=0;return r.forEach((({count:t})=>s+=t)),n!==s}(n,e.range)&&!e.verbose&&console.warn('MeshBVH: Provided geometry contains groups or a range that do not fully span the vertex contents while using the "indirect" option. BVH may incorrectly report intersections on unrendered portions of the geometry.')),t._indirectBuffer||b(n,e);const r=e.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer,o=function(t,e=null,n=null,r=null){const o=t.attributes.position,s=t.index?t.index.array:null,i=B(t),a=o.normalized;let c;null===e?(c=new Float32Array(6*i),n=0,r=i):(c=e,n=n||0,r=r||i);const l=o.array,u=o.offset||0;let f=3;o.isInterleavedBufferAttribute&&(f=o.data.stride);const d=["getX","getY","getZ"];for(let t=n;t<n+r;t++){const e=3*t,n=6*t;let r=e+0,i=e+1,p=e+2;s&&(r=s[r],i=s[i],p=s[p]),a||(r=r*f+u,i=i*f+u,p=p*f+u);for(let t=0;t<3;t++){let e,s,u;a?(e=o[d[t]](r),s=o[d[t]](i),u=o[d[t]](p)):(e=l[r+t],s=l[i+t],u=l[p+t]);let f=e;s<f&&(f=s),u<f&&(f=u);let h=e;s>h&&(h=s),u>h&&(h=u);const y=(h-f)/2,g=2*t;c[n+g+0]=f+y,c[n+g+1]=y+(Math.abs(f)+y)*m}}return c}(n),s=e.indirect?A(n,e.range):T(n,e.range);t._roots=s.map((n=>{const s=J(t,o,n.offset,n.count,e),i=j(s),a=new r(32*i);return $(0,s,a),a}))}class tt{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,e){let n=1/0,r=-1/0;for(let o=0,s=t.length;o<s;o++){const s=t[o][e];n=s<n?s:n,r=s>r?s:r}this.min=n,this.max=r}setFromPoints(t,e){let n=1/0,r=-1/0;for(let o=0,s=e.length;o<s;o++){const s=e[o],i=t.dot(s);n=i<n?i:n,r=i>r?i:r}this.min=n,this.max=r}isSeparated(t){return this.min>t.max||t.min>this.max}}tt.prototype.setFromBox=function(){const e=new t;return function(t,n){const r=n.min,o=n.max;let s=1/0,i=-1/0;for(let n=0;n<=1;n++)for(let a=0;a<=1;a++)for(let c=0;c<=1;c++){e.x=r.x*n+o.x*(1-n),e.y=r.y*a+o.y*(1-a),e.z=r.z*c+o.z*(1-c);const l=t.dot(e);s=Math.min(l,s),i=Math.max(l,i)}this.min=s,this.max=i}}();const et=function(){const e=new t,n=new t,r=new t;return function(t,o,s){const i=t.start,a=e,c=o.start,l=n;r.subVectors(i,c),e.subVectors(t.end,t.start),n.subVectors(o.end,o.start);const u=r.dot(l),f=l.dot(a),d=l.dot(l),p=r.dot(a),h=a.dot(a)*d-f*f;let y,g;y=0!==h?(u*f-p*d)/h:0,g=(u+y*f)/d,s.x=y,s.y=g}}(),nt=function(){const n=new e,r=new t,o=new t;return function(t,e,s,i){et(t,e,n);let a=n.x,c=n.y;if(a>=0&&a<=1&&c>=0&&c<=1)return t.at(a,s),void e.at(c,i);if(a>=0&&a<=1)return c<0?e.at(0,i):e.at(1,i),void t.closestPointToPoint(i,!0,s);if(c>=0&&c<=1)return a<0?t.at(0,s):t.at(1,s),void e.closestPointToPoint(s,!0,i);{let n,l;n=a<0?t.start:t.end,l=c<0?e.start:e.end;const u=r,f=o;return t.closestPointToPoint(l,!0,r),e.closestPointToPoint(n,!0,o),u.distanceToSquared(l)<=f.distanceToSquared(n)?(s.copy(u),void i.copy(l)):(s.copy(n),void i.copy(f))}}}(),rt=function(){const e=new t,o=new t,s=new n,i=new r;return function(t,n){const{radius:r,center:a}=t,{a:c,b:l,c:u}=n;i.start=c,i.end=l;if(i.closestPointToPoint(a,!0,e).distanceTo(a)<=r)return!0;i.start=c,i.end=u;if(i.closestPointToPoint(a,!0,e).distanceTo(a)<=r)return!0;i.start=l,i.end=u;if(i.closestPointToPoint(a,!0,e).distanceTo(a)<=r)return!0;const f=n.getPlane(s);if(Math.abs(f.distanceToPoint(a))<=r){const t=f.projectPoint(a,o);if(n.containsPoint(t))return!0}return!1}}();function ot(t){return Math.abs(t)<1e-15}class st extends a{constructor(...e){super(...e),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map((()=>new t)),this.satBounds=new Array(4).fill().map((()=>new tt)),this.points=[this.a,this.b,this.c],this.sphere=new c,this.plane=new n,this.needsUpdate=!0}intersectsSphere(t){return rt(t,this)}update(){const t=this.a,e=this.b,n=this.c,r=this.points,o=this.satAxes,s=this.satBounds,i=o[0],a=s[0];this.getNormal(i),a.setFromPoints(i,r);const c=o[1],l=s[1];c.subVectors(t,e),l.setFromPoints(c,r);const u=o[2],f=s[2];u.subVectors(e,n),f.setFromPoints(u,r);const d=o[3],p=s[3];d.subVectors(n,t),p.setFromPoints(d,r),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(i,t),this.needsUpdate=!1}}st.prototype.closestPointToSegment=function(){const e=new t,n=new t,o=new r;return function(t,r=null,s=null){const{start:i,end:a}=t,c=this.points;let l,u=1/0;for(let i=0;i<3;i++){const a=(i+1)%3;o.start.copy(c[i]),o.end.copy(c[a]),nt(o,t,e,n),l=e.distanceToSquared(n),l<u&&(u=l,r&&r.copy(e),s&&s.copy(n))}return this.closestPointToPoint(i,e),l=i.distanceToSquared(e),l<u&&(u=l,r&&r.copy(e),s&&s.copy(i)),this.closestPointToPoint(a,e),l=a.distanceToSquared(e),l<u&&(u=l,r&&r.copy(e),s&&s.copy(a)),Math.sqrt(u)}}(),st.prototype.intersectsTriangle=function(){const e=new st,n=new Array(3),o=new Array(3),s=new tt,i=new tt,a=new t,c=new t,l=new t,u=new t,f=new t,d=new r,p=new r,h=new r,y=new t;function g(t,e,n){const r=t.points;let o=0,s=-1;for(let t=0;t<3;t++){const{start:i,end:a}=d;i.copy(r[t]),a.copy(r[(t+1)%3]),d.delta(c);const l=ot(e.distanceToPoint(i));if(ot(e.normal.dot(c))&&l){n.copy(d),o=2;break}const u=e.intersectLine(d,y);if(!u&&l&&y.copy(i),(u||l)&&!ot(y.distanceTo(a))){if(o<=1){(1===o?n.start:n.end).copy(y),l&&(s=o)}else if(o>=2){(1===s?n.start:n.end).copy(y),o=2;break}if(o++,2===o&&-1===s)break}}return o}return function(t,r=null,c=!1){this.needsUpdate&&this.update(),t.isExtendedTriangle?t.needsUpdate&&t.update():(e.copy(t),e.update(),t=e);const d=this.plane,y=t.plane;if(Math.abs(d.normal.dot(y.normal))>1-1e-10){const e=this.satBounds,l=this.satAxes;o[0]=t.a,o[1]=t.b,o[2]=t.c;for(let t=0;t<4;t++){const n=e[t],r=l[t];if(s.setFromPoints(r,o),n.isSeparated(s))return!1}const u=t.satBounds,f=t.satAxes;n[0]=this.a,n[1]=this.b,n[2]=this.c;for(let t=0;t<4;t++){const e=u[t],r=f[t];if(s.setFromPoints(r,n),e.isSeparated(s))return!1}for(let t=0;t<4;t++){const e=l[t];for(let t=0;t<4;t++){const r=f[t];if(a.crossVectors(e,r),s.setFromPoints(a,n),i.setFromPoints(a,o),s.isSeparated(i))return!1}}return r&&(c||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),r.start.set(0,0,0),r.end.set(0,0,0)),!0}{const e=g(this,y,p);if(1===e&&t.containsPoint(p.end))return r&&(r.start.copy(p.end),r.end.copy(p.end)),!0;if(2!==e)return!1;const n=g(t,d,h);if(1===n&&this.containsPoint(h.end))return r&&(r.start.copy(h.end),r.end.copy(h.end)),!0;if(2!==n)return!1;if(p.delta(l),h.delta(u),l.dot(u)<0){let t=h.start;h.start=h.end,h.end=t}const o=p.start.dot(l),s=p.end.dot(l),i=h.start.dot(l),a=h.end.dot(l);return(o===a||i===s||s<i!==o<a)&&(r&&(f.subVectors(p.start,h.start),f.dot(l)>0?r.start.copy(p.start):r.start.copy(h.start),f.subVectors(p.end,h.end),f.dot(l)<0?r.end.copy(p.end):r.end.copy(h.end)),!0)}}}(),st.prototype.distanceToPoint=function(){const e=new t;return function(t){return this.closestPointToPoint(t,e),t.distanceTo(e)}}(),st.prototype.distanceToTriangle=function(){const e=new t,n=new t,o=["a","b","c"],s=new r,i=new r;return function(t,r=null,a=null){const c=r||a?s:null;if(this.intersectsTriangle(t,c))return(r||a)&&(r&&c.getCenter(r),a&&c.getCenter(a)),0;let l=1/0;for(let n=0;n<3;n++){let s;const i=o[n],c=t[i];this.closestPointToPoint(c,e),s=c.distanceToSquared(e),s<l&&(l=s,r&&r.copy(e),a&&a.copy(c));const u=this[i];t.closestPointToPoint(u,e),s=u.distanceToSquared(e),s<l&&(l=s,r&&r.copy(u),a&&a.copy(e))}for(let c=0;c<3;c++){const u=o[c],f=o[(c+1)%3];s.set(this[u],this[f]);for(let c=0;c<3;c++){const u=o[c],f=o[(c+1)%3];i.set(t[u],t[f]),nt(s,i,e,n);const d=e.distanceToSquared(n);d<l&&(l=d,r&&r.copy(e),a&&a.copy(n))}}return Math.sqrt(l)}}();class it{constructor(e,n,r){this.isOrientedBox=!0,this.min=new t,this.max=new t,this.matrix=new l,this.invMatrix=new l,this.points=new Array(8).fill().map((()=>new t)),this.satAxes=new Array(3).fill().map((()=>new t)),this.satBounds=new Array(3).fill().map((()=>new tt)),this.alignedSatBounds=new Array(3).fill().map((()=>new tt)),this.needsUpdate=!1,e&&this.min.copy(e),n&&this.max.copy(n),r&&this.matrix.copy(r)}set(t,e,n){this.min.copy(t),this.max.copy(e),this.matrix.copy(n),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}it.prototype.update=function(){const t=this.matrix,e=this.min,n=this.max,r=this.points;for(let o=0;o<=1;o++)for(let s=0;s<=1;s++)for(let i=0;i<=1;i++){const a=r[1*o|2*s|4*i];a.x=o?n.x:e.x,a.y=s?n.y:e.y,a.z=i?n.z:e.z,a.applyMatrix4(t)}const o=this.satBounds,s=this.satAxes,i=r[0];for(let t=0;t<3;t++){const e=s[t],n=o[t],a=r[1<<t];e.subVectors(i,a),n.setFromPoints(e,r)}const a=this.alignedSatBounds;a[0].setFromPointsField(r,"x"),a[1].setFromPointsField(r,"y"),a[2].setFromPointsField(r,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1},it.prototype.intersectsBox=function(){const t=new tt;return function(e){this.needsUpdate&&this.update();const n=e.min,r=e.max,o=this.satBounds,s=this.satAxes,i=this.alignedSatBounds;if(t.min=n.x,t.max=r.x,i[0].isSeparated(t))return!1;if(t.min=n.y,t.max=r.y,i[1].isSeparated(t))return!1;if(t.min=n.z,t.max=r.z,i[2].isSeparated(t))return!1;for(let n=0;n<3;n++){const r=s[n],i=o[n];if(t.setFromBox(r,e),i.isSeparated(t))return!1}return!0}}(),it.prototype.intersectsTriangle=function(){const e=new st,n=new Array(3),r=new tt,o=new tt,s=new t;return function(t){this.needsUpdate&&this.update(),t.isExtendedTriangle?t.needsUpdate&&t.update():(e.copy(t),e.update(),t=e);const i=this.satBounds,a=this.satAxes;n[0]=t.a,n[1]=t.b,n[2]=t.c;for(let t=0;t<3;t++){const e=i[t],o=a[t];if(r.setFromPoints(o,n),e.isSeparated(r))return!1}const c=t.satBounds,l=t.satAxes,u=this.points;for(let t=0;t<3;t++){const e=c[t],n=l[t];if(r.setFromPoints(n,u),e.isSeparated(r))return!1}for(let t=0;t<3;t++){const e=a[t];for(let t=0;t<4;t++){const i=l[t];if(s.crossVectors(e,i),r.setFromPoints(s,n),o.setFromPoints(s,u),r.isSeparated(o))return!1}}return!0}}(),it.prototype.closestPointToPoint=function(t,e){return this.needsUpdate&&this.update(),e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e},it.prototype.distanceToPoint=function(){const e=new t;return function(t){return this.closestPointToPoint(t,e),t.distanceTo(e)}}(),it.prototype.distanceToBox=function(){const e=["x","y","z"],n=new Array(12).fill().map((()=>new r)),o=new Array(12).fill().map((()=>new r)),s=new t,i=new t;return function(t,r=0,a=null,c=null){if(this.needsUpdate&&this.update(),this.intersectsBox(t))return(a||c)&&(t.getCenter(i),this.closestPointToPoint(i,s),t.closestPointToPoint(s,i),a&&a.copy(s),c&&c.copy(i)),0;const l=r*r,u=t.min,f=t.max,d=this.points;let p=1/0;for(let t=0;t<8;t++){const e=d[t];i.copy(e).clamp(u,f);const n=e.distanceToSquared(i);if(n<p&&(p=n,a&&a.copy(e),c&&c.copy(i),n<l))return Math.sqrt(n)}let h=0;for(let t=0;t<3;t++)for(let r=0;r<=1;r++)for(let s=0;s<=1;s++){const i=(t+1)%3,a=(t+2)%3,c=1<<t|r<<i|s<<a,l=d[r<<i|s<<a],p=d[c];n[h].set(l,p);const y=e[t],g=e[i],x=e[a],m=o[h],w=m.start,B=m.end;w[y]=u[y],w[g]=r?u[g]:f[g],w[x]=s?u[x]:f[g],B[y]=f[y],B[g]=r?u[g]:f[g],B[x]=s?u[x]:f[g],h++}for(let t=0;t<=1;t++)for(let e=0;e<=1;e++)for(let n=0;n<=1;n++){i.x=t?f.x:u.x,i.y=e?f.y:u.y,i.z=n?f.z:u.z,this.closestPointToPoint(i,s);const r=i.distanceToSquared(s);if(r<p&&(p=r,a&&a.copy(s),c&&c.copy(i),r<l))return Math.sqrt(r)}for(let t=0;t<12;t++){const e=n[t];for(let t=0;t<12;t++){const n=o[t];nt(e,n,s,i);const r=s.distanceToSquared(i);if(r<p&&(p=r,a&&a.copy(s),c&&c.copy(i),r<l))return Math.sqrt(r)}}return Math.sqrt(p)}}();class at{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return 0===t.length?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}class ct extends at{constructor(){super((()=>new st))}}const lt=new ct;const ut=new class{constructor(){this.float32Array=null,this.uint16Array=null,this.uint32Array=null;const t=[];let e=null;this.setBuffer=n=>{e&&t.push(e),e=n,this.float32Array=new Float32Array(n),this.uint16Array=new Uint16Array(n),this.uint32Array=new Uint32Array(n)},this.clearBuffer=()=>{e=null,this.float32Array=null,this.uint16Array=null,this.uint32Array=null,0!==t.length&&this.setBuffer(t.pop())}}};let ft,dt;const pt=[],ht=new at((()=>new o));function yt(t,e,n,r,o,s){ft=ht.getPrimitive(),dt=ht.getPrimitive(),pt.push(ft,dt),ut.setBuffer(t._roots[e]);const i=gt(0,t.geometry,n,r,o,s);ut.clearBuffer(),ht.releasePrimitive(ft),ht.releasePrimitive(dt),pt.pop(),pt.pop();const a=pt.length;return a>0&&(dt=pt[a-1],ft=pt[a-2]),i}function gt(t,e,n,r,o=null,s=0,i=0){const{float32Array:a,uint16Array:c,uint32Array:l}=ut;let u=2*t;if(X(u,c)){const f=H(t,l),d=N(u,c);return v(t,a,ft),r(f,d,!1,i,s+t,ft)}{const p=O(t),h=D(t,l);let y,g,x,m,w=p,B=h;if(o&&(x=ft,m=dt,v(w,a,x),v(B,a,m),y=o(x),g=o(m),g<y)){w=h,B=p;const S=y;y=g,g=S,x=m}x||(x=ft,v(w,a,x));const b=n(x,X(2*w,c),y,i+1,s+w);let A;if(2===b){const I=M(w);A=r(I,U(w)-I,!0,i+1,s+w,x)}else A=b&&gt(w,e,n,r,o,s,i+1);if(A)return!0;m=dt,v(B,a,m);const T=n(m,X(2*B,c),g,i+1,s+B);let P;if(2===T){const _=M(B);P=r(_,U(B)-_,!0,i+1,s+B,m)}else P=T&&gt(B,e,n,r,o,s,i+1);return!!P;function M(t){const{uint16Array:e,uint32Array:n}=ut;let r=2*t;for(;!X(r,e);)r=2*(t=O(t));return H(t,n)}function U(t){const{uint16Array:e,uint32Array:n}=ut;let r=2*t;for(;!X(r,e);)r=2*(t=D(t,n));return H(t,n)+N(r,e)}}}const xt=new t,mt=new t;const wt=parseInt(f)>=169,Bt=new t,bt=new t,At=new t,Tt=new e,Pt=new e,vt=new e,Mt=new t,Ut=new t,St=new t,It=new t;function _t(n,r,o,s,i,c,l,u,f,d,p){Bt.fromBufferAttribute(r,c),bt.fromBufferAttribute(r,l),At.fromBufferAttribute(r,u);const g=function(t,e,n,r,o,s,i,a){let c;if(c=s===h?t.intersectTriangle(r,n,e,!0,o):t.intersectTriangle(e,n,r,s!==y,o),null===c)return null;const l=t.origin.distanceTo(o);return l<i||l>a?null:{distance:l,point:o.clone()}}(n,Bt,bt,At,It,f,d,p);if(g){const r=new t;a.getBarycoord(It,Bt,bt,At,r),s&&(Tt.fromBufferAttribute(s,c),Pt.fromBufferAttribute(s,l),vt.fromBufferAttribute(s,u),g.uv=a.getInterpolation(It,Bt,bt,At,Tt,Pt,vt,new e)),i&&(Tt.fromBufferAttribute(i,c),Pt.fromBufferAttribute(i,l),vt.fromBufferAttribute(i,u),g.uv1=a.getInterpolation(It,Bt,bt,At,Tt,Pt,vt,new e)),o&&(Mt.fromBufferAttribute(o,c),Ut.fromBufferAttribute(o,l),St.fromBufferAttribute(o,u),g.normal=a.getInterpolation(It,Bt,bt,At,Mt,Ut,St,new t),g.normal.dot(n.direction)>0&&g.normal.multiplyScalar(-1));const f={a:c,b:l,c:u,normal:new t,materialIndex:0};a.getNormal(Bt,bt,At,f.normal),g.face=f,g.faceIndex=c,wt&&(g.barycoord=r)}return g}function Ft(t,e,n,r,o,s,i){const a=3*r;let c=a+0,l=a+1,u=a+2;const f=t.index;t.index&&(c=f.getX(c),l=f.getX(l),u=f.getX(u));const{position:d,normal:p,uv:h,uv1:y}=t.attributes,g=_t(n,d,p,h,y,c,l,u,e,s,i);return g?(g.faceIndex=r,o&&o.push(g),g):null}function zt(t,e,n,r){const o=t.a,s=t.b,i=t.c;let a=e,c=e+1,l=e+2;n&&(a=n.getX(a),c=n.getX(c),l=n.getX(l)),o.x=r.getX(a),o.y=r.getY(a),o.z=r.getZ(a),s.x=r.getX(c),s.y=r.getY(c),s.z=r.getZ(c),i.x=r.getX(l),i.y=r.getY(l),i.z=r.getZ(l)}function Vt(t,e,n,r,o,s,i){const{geometry:a}=n,{index:c}=a,l=a.attributes.position;for(let n=t,a=e+t;n<a;n++){let t;if(t=n,zt(i,3*t,c,l),i.needsUpdate=!0,r(i,t,o,s))return!0}return!1}function qt(t,e=null){e&&Array.isArray(e)&&(e=new Set(e));const n=t.geometry,r=n.index?n.index.array:null,o=n.attributes.position;let s,i,a,c,l=0;const u=t._roots;for(let t=0,e=u.length;t<e;t++)s=u[t],i=new Uint32Array(s),a=new Uint16Array(s),c=new Float32Array(s),f(0,l),l+=s.byteLength;function f(t,n,s=!1){const l=2*t;if(a[l+15]===x){const e=i[t+6];let n=1/0,s=1/0,u=1/0,f=-1/0,d=-1/0,p=-1/0;for(let t=3*e,i=3*(e+a[l+14]);t<i;t++){let e=r[t];const i=o.getX(e),a=o.getY(e),c=o.getZ(e);i<n&&(n=i),i>f&&(f=i),a<s&&(s=a),a>d&&(d=a),c<u&&(u=c),c>p&&(p=c)}return(c[t+0]!==n||c[t+1]!==s||c[t+2]!==u||c[t+3]!==f||c[t+4]!==d||c[t+5]!==p)&&(c[t+0]=n,c[t+1]=s,c[t+2]=u,c[t+3]=f,c[t+4]=d,c[t+5]=p,!0)}{const r=t+8,o=i[t+6],a=r+n,l=o+n;let u=s,d=!1,p=!1;e?u||(d=e.has(a),p=e.has(l),u=!d&&!p):(d=!0,p=!0);const h=u||p;let y=!1;(u||d)&&(y=f(r,n,u));let g=!1;h&&(g=f(o,n,u));const x=y||g;if(x)for(let e=0;e<3;e++){const n=r+e,s=o+e,i=c[n],a=c[n+3],l=c[s],u=c[s+3];c[t+e]=i<l?i:l,c[t+e+3]=a>u?a:u}return x}}}function Ct(t,e,n,r,o){let s,i,a,c,l,u;const f=1/n.direction.x,d=1/n.direction.y,p=1/n.direction.z,h=n.origin.x,y=n.origin.y,g=n.origin.z;let x=e[t],m=e[t+3],w=e[t+1],B=e[t+3+1],b=e[t+2],A=e[t+3+2];return f>=0?(s=(x-h)*f,i=(m-h)*f):(s=(m-h)*f,i=(x-h)*f),d>=0?(a=(w-y)*d,c=(B-y)*d):(a=(B-y)*d,c=(w-y)*d),!(s>c||a>i)&&((a>s||isNaN(s))&&(s=a),(c<i||isNaN(i))&&(i=c),p>=0?(l=(b-g)*p,u=(A-g)*p):(l=(A-g)*p,u=(b-g)*p),!(s>u||l>i)&&((l>s||s!=s)&&(s=l),(u<i||i!=i)&&(i=u),s<=o&&i>=r))}function Et(t,e,n,r,o,s,i){const{geometry:a}=n,{index:c}=a,l=a.attributes.position;for(let a=t,u=e+t;a<u;a++){let t;if(t=n.resolveTriangleIndex(a),zt(i,3*t,c,l),i.needsUpdate=!0,r(i,t,o,s))return!0}return!1}function Rt(t,e,n,r,o,s,i){ut.setBuffer(t._roots[e]),Xt(0,t,n,r,o,s,i),ut.clearBuffer()}function Xt(t,e,n,r,o,s,i){const{float32Array:a,uint16Array:c,uint32Array:l}=ut,u=2*t;if(X(u,c)){!function(t,e,n,r,o,s,i,a){const{geometry:c,_indirectBuffer:l}=t;for(let t=r,l=r+o;t<l;t++)Ft(c,e,n,t,s,i,a)}(e,n,r,H(t,l),N(u,c),o,s,i)}else{const c=O(t);Ct(c,a,r,s,i)&&Xt(c,e,n,r,o,s,i);const u=D(t,l);Ct(u,a,r,s,i)&&Xt(u,e,n,r,o,s,i)}}const Ht=["x","y","z"];function Nt(t,e,n,r,o,s){ut.setBuffer(t._roots[e]);const i=Ot(0,t,n,r,o,s);return ut.clearBuffer(),i}function Ot(t,e,n,r,o,s){const{float32Array:i,uint16Array:a,uint32Array:c}=ut;let l=2*t;if(X(l,a)){return function(t,e,n,r,o,s,i){const{geometry:a,_indirectBuffer:c}=t;let l=1/0,u=null;for(let t=r,c=r+o;t<c;t++){let r;r=Ft(a,e,n,t,null,s,i),r&&r.distance<l&&(u=r,l=r.distance)}return u}(e,n,r,H(t,c),N(l,a),o,s)}{const a=L(t,c),l=Ht[a],u=r.direction[l]>=0;let f,d;u?(f=O(t),d=D(t,c)):(f=D(t,c),d=O(t));const p=Ct(f,i,r,o,s)?Ot(f,e,n,r,o,s):null;if(p){const t=p.point[l];if(u?t<=i[d+a]:t>=i[d+a+3])return p}const h=Ct(d,i,r,o,s)?Ot(d,e,n,r,o,s):null;return p&&h?p.distance<=h.distance?p:h:p||h||null}}const Dt=new o,Lt=new st,kt=new st,Yt=new l,Zt=new it,Gt=new it;function Wt(t,e,n,r){ut.setBuffer(t._roots[e]);const o=jt(0,t,n,r);return ut.clearBuffer(),o}function jt(t,e,n,r,o=null){const{float32Array:s,uint16Array:i,uint32Array:a}=ut;let c=2*t;null===o&&(n.boundingBox||n.computeBoundingBox(),Zt.set(n.boundingBox.min,n.boundingBox.max,r),o=Zt);if(!X(c,i)){const i=t+8,c=a[t+6];v(i,s,Dt);if(o.intersectsBox(Dt)&&jt(i,e,n,r,o))return!0;v(c,s,Dt);return!!(o.intersectsBox(Dt)&&jt(c,e,n,r,o))}{const o=e.geometry,l=o.index,u=o.attributes.position,f=n.index,d=n.attributes.position,p=H(t,a),h=N(c,i);if(Yt.copy(r).invert(),n.boundsTree){v(t,s,Gt),Gt.matrix.copy(Yt),Gt.needsUpdate=!0;return n.boundsTree.shapecast({intersectsBounds:t=>Gt.intersectsBox(t),intersectsTriangle:t=>{t.a.applyMatrix4(r),t.b.applyMatrix4(r),t.c.applyMatrix4(r),t.needsUpdate=!0;for(let e=3*p,n=3*(h+p);e<n;e+=3)if(zt(kt,e,l,u),kt.needsUpdate=!0,t.intersectsTriangle(kt))return!0;return!1}})}for(let t=3*p,e=3*(h+p);t<e;t+=3){zt(Lt,t,l,u),Lt.a.applyMatrix4(Yt),Lt.b.applyMatrix4(Yt),Lt.c.applyMatrix4(Yt),Lt.needsUpdate=!0;for(let t=0,e=f.count;t<e;t+=3)if(zt(kt,t,f,d),kt.needsUpdate=!0,Lt.intersectsTriangle(kt))return!0}}}const $t=new l,Kt=new it,Jt=new it,Qt=new t,te=new t,ee=new t,ne=new t;function re(t,e,n,r={},o={},s=0,i=1/0){e.boundingBox||e.computeBoundingBox(),Kt.set(e.boundingBox.min,e.boundingBox.max,n),Kt.needsUpdate=!0;const a=t.geometry,c=a.attributes.position,l=a.index,u=e.attributes.position,f=e.index,d=lt.getPrimitive(),p=lt.getPrimitive();let h=Qt,y=te,g=null,x=null;o&&(g=ee,x=ne);let m=1/0,w=null,b=null;return $t.copy(n).invert(),Jt.matrix.copy($t),t.shapecast({boundsTraverseOrder:t=>Kt.distanceToBox(t),intersectsBounds:(t,e,n)=>n<m&&n<i&&(e&&(Jt.min.copy(t.min),Jt.max.copy(t.max),Jt.needsUpdate=!0),!0),intersectsRange:(t,r)=>{if(e.boundsTree){return e.boundsTree.shapecast({boundsTraverseOrder:t=>Jt.distanceToBox(t),intersectsBounds:(t,e,n)=>n<m&&n<i,intersectsRange:(e,o)=>{for(let i=e,a=e+o;i<a;i++){zt(p,3*i,f,u),p.a.applyMatrix4(n),p.b.applyMatrix4(n),p.c.applyMatrix4(n),p.needsUpdate=!0;for(let e=t,n=t+r;e<n;e++){zt(d,3*e,l,c),d.needsUpdate=!0;const t=d.distanceToTriangle(p,h,g);if(t<m&&(y.copy(h),x&&x.copy(g),m=t,w=e,b=i),t<s)return!0}}}})}for(let o=0,i=B(e);o<i;o++){zt(p,3*o,f,u),p.a.applyMatrix4(n),p.b.applyMatrix4(n),p.c.applyMatrix4(n),p.needsUpdate=!0;for(let e=t,n=t+r;e<n;e++){zt(d,3*e,l,c),d.needsUpdate=!0;const t=d.distanceToTriangle(p,h,g);if(t<m&&(y.copy(h),x&&x.copy(g),m=t,w=e,b=o),t<s)return!0}}}}),lt.releasePrimitive(d),lt.releasePrimitive(p),m===1/0?null:(r.point?r.point.copy(y):r.point=y.clone(),r.distance=m,r.faceIndex=w,o&&(o.point?o.point.copy(x):o.point=x.clone(),o.point.applyMatrix4($t),y.applyMatrix4($t),o.distance=y.sub(o.point).length(),o.faceIndex=b),r)}function oe(t,e=null){e&&Array.isArray(e)&&(e=new Set(e));const n=t.geometry,r=n.index?n.index.array:null,o=n.attributes.position;let s,i,a,c,l=0;const u=t._roots;for(let t=0,e=u.length;t<e;t++)s=u[t],i=new Uint32Array(s),a=new Uint16Array(s),c=new Float32Array(s),f(0,l),l+=s.byteLength;function f(n,s,l=!1){const u=2*n;if(a[u+15]===x){const e=i[n+6];let s=1/0,l=1/0,f=1/0,d=-1/0,p=-1/0,h=-1/0;for(let n=e,i=e+a[u+14];n<i;n++){const e=3*t.resolveTriangleIndex(n);for(let t=0;t<3;t++){let n=e+t;n=r?r[n]:n;const i=o.getX(n),a=o.getY(n),c=o.getZ(n);i<s&&(s=i),i>d&&(d=i),a<l&&(l=a),a>p&&(p=a),c<f&&(f=c),c>h&&(h=c)}}return(c[n+0]!==s||c[n+1]!==l||c[n+2]!==f||c[n+3]!==d||c[n+4]!==p||c[n+5]!==h)&&(c[n+0]=s,c[n+1]=l,c[n+2]=f,c[n+3]=d,c[n+4]=p,c[n+5]=h,!0)}{const t=n+8,r=i[n+6],o=t+s,a=r+s;let u=l,d=!1,p=!1;e?u||(d=e.has(o),p=e.has(a),u=!d&&!p):(d=!0,p=!0);const h=u||p;let y=!1;(u||d)&&(y=f(t,s,u));let g=!1;h&&(g=f(r,s,u));const x=y||g;if(x)for(let e=0;e<3;e++){const o=t+e,s=r+e,i=c[o],a=c[o+3],l=c[s],u=c[s+3];c[n+e]=i<l?i:l,c[n+e+3]=a>u?a:u}return x}}}function se(t,e,n,r,o,s,i){ut.setBuffer(t._roots[e]),ie(0,t,n,r,o,s,i),ut.clearBuffer()}function ie(t,e,n,r,o,s,i){const{float32Array:a,uint16Array:c,uint32Array:l}=ut,u=2*t;if(X(u,c)){!function(t,e,n,r,o,s,i,a){const{geometry:c,_indirectBuffer:l}=t;for(let t=r,u=r+o;t<u;t++)Ft(c,e,n,l?l[t]:t,s,i,a)}(e,n,r,H(t,l),N(u,c),o,s,i)}else{const c=O(t);Ct(c,a,r,s,i)&&ie(c,e,n,r,o,s,i);const u=D(t,l);Ct(u,a,r,s,i)&&ie(u,e,n,r,o,s,i)}}const ae=["x","y","z"];function ce(t,e,n,r,o,s){ut.setBuffer(t._roots[e]);const i=le(0,t,n,r,o,s);return ut.clearBuffer(),i}function le(t,e,n,r,o,s){const{float32Array:i,uint16Array:a,uint32Array:c}=ut;let l=2*t;if(X(l,a)){return function(t,e,n,r,o,s,i){const{geometry:a,_indirectBuffer:c}=t;let l=1/0,u=null;for(let t=r,f=r+o;t<f;t++){let r;r=Ft(a,e,n,c?c[t]:t,null,s,i),r&&r.distance<l&&(u=r,l=r.distance)}return u}(e,n,r,H(t,c),N(l,a),o,s)}{const a=L(t,c),l=ae[a],u=r.direction[l]>=0;let f,d;u?(f=O(t),d=D(t,c)):(f=D(t,c),d=O(t));const p=Ct(f,i,r,o,s)?le(f,e,n,r,o,s):null;if(p){const t=p.point[l];if(u?t<=i[d+a]:t>=i[d+a+3])return p}const h=Ct(d,i,r,o,s)?le(d,e,n,r,o,s):null;return p&&h?p.distance<=h.distance?p:h:p||h||null}}const ue=new o,fe=new st,de=new st,pe=new l,he=new it,ye=new it;function ge(t,e,n,r){ut.setBuffer(t._roots[e]);const o=xe(0,t,n,r);return ut.clearBuffer(),o}function xe(t,e,n,r,o=null){const{float32Array:s,uint16Array:i,uint32Array:a}=ut;let c=2*t;null===o&&(n.boundingBox||n.computeBoundingBox(),he.set(n.boundingBox.min,n.boundingBox.max,r),o=he);if(!X(c,i)){const i=t+8,c=a[t+6];v(i,s,ue);if(o.intersectsBox(ue)&&xe(i,e,n,r,o))return!0;v(c,s,ue);return!!(o.intersectsBox(ue)&&xe(c,e,n,r,o))}{const o=e.geometry,l=o.index,u=o.attributes.position,f=n.index,d=n.attributes.position,p=H(t,a),h=N(c,i);if(pe.copy(r).invert(),n.boundsTree){v(t,s,ye),ye.matrix.copy(pe),ye.needsUpdate=!0;return n.boundsTree.shapecast({intersectsBounds:t=>ye.intersectsBox(t),intersectsTriangle:t=>{t.a.applyMatrix4(r),t.b.applyMatrix4(r),t.c.applyMatrix4(r),t.needsUpdate=!0;for(let n=p,r=h+p;n<r;n++)if(zt(de,3*e.resolveTriangleIndex(n),l,u),de.needsUpdate=!0,t.intersectsTriangle(de))return!0;return!1}})}for(let t=p,n=h+p;t<n;t++){const n=e.resolveTriangleIndex(t);zt(fe,3*n,l,u),fe.a.applyMatrix4(pe),fe.b.applyMatrix4(pe),fe.c.applyMatrix4(pe),fe.needsUpdate=!0;for(let t=0,e=f.count;t<e;t+=3)if(zt(de,t,f,d),de.needsUpdate=!0,fe.intersectsTriangle(de))return!0}}}const me=new l,we=new it,Be=new it,be=new t,Ae=new t,Te=new t,Pe=new t;function ve(t,e,n,r={},o={},s=0,i=1/0){e.boundingBox||e.computeBoundingBox(),we.set(e.boundingBox.min,e.boundingBox.max,n),we.needsUpdate=!0;const a=t.geometry,c=a.attributes.position,l=a.index,u=e.attributes.position,f=e.index,d=lt.getPrimitive(),p=lt.getPrimitive();let h=be,y=Ae,g=null,x=null;o&&(g=Te,x=Pe);let m=1/0,w=null,b=null;return me.copy(n).invert(),Be.matrix.copy(me),t.shapecast({boundsTraverseOrder:t=>we.distanceToBox(t),intersectsBounds:(t,e,n)=>n<m&&n<i&&(e&&(Be.min.copy(t.min),Be.max.copy(t.max),Be.needsUpdate=!0),!0),intersectsRange:(r,o)=>{if(e.boundsTree){const a=e.boundsTree;return a.shapecast({boundsTraverseOrder:t=>Be.distanceToBox(t),intersectsBounds:(t,e,n)=>n<m&&n<i,intersectsRange:(e,i)=>{for(let B=e,A=e+i;B<A;B++){const e=a.resolveTriangleIndex(B);zt(p,3*e,f,u),p.a.applyMatrix4(n),p.b.applyMatrix4(n),p.c.applyMatrix4(n),p.needsUpdate=!0;for(let e=r,n=r+o;e<n;e++){const n=t.resolveTriangleIndex(e);zt(d,3*n,l,c),d.needsUpdate=!0;const r=d.distanceToTriangle(p,h,g);if(r<m&&(y.copy(h),x&&x.copy(g),m=r,w=e,b=B),r<s)return!0}}}})}for(let i=0,a=B(e);i<a;i++){zt(p,3*i,f,u),p.a.applyMatrix4(n),p.b.applyMatrix4(n),p.c.applyMatrix4(n),p.needsUpdate=!0;for(let e=r,n=r+o;e<n;e++){const n=t.resolveTriangleIndex(e);zt(d,3*n,l,c),d.needsUpdate=!0;const r=d.distanceToTriangle(p,h,g);if(r<m&&(y.copy(h),x&&x.copy(g),m=r,w=e,b=i),r<s)return!0}}}}),lt.releasePrimitive(d),lt.releasePrimitive(p),m===1/0?null:(r.point?r.point.copy(y):r.point=y.clone(),r.distance=m,r.faceIndex=w,o&&(o.point?o.point.copy(x):o.point=x.clone(),o.point.applyMatrix4(me),y.applyMatrix4(me),o.distance=y.sub(o.point).length(),o.faceIndex=b),r)}const Me=new ut.constructor,Ue=new ut.constructor,Se=new at((()=>new o)),Ie=new o,_e=new o,Fe=new o,ze=new o;let Ve=!1;function qe(t,e,n,r,o,s=0,i=0,a=0,c=0,l=null,u=!1){let f,d;u?(f=Ue,d=Me):(f=Me,d=Ue);const p=f.float32Array,h=f.uint32Array,y=f.uint16Array,g=d.float32Array,x=d.uint32Array,m=d.uint16Array,w=2*e,B=X(2*t,y),b=X(w,m);let A=!1;if(b&&B)A=u?o(H(e,x),N(2*e,m),H(t,h),N(2*t,y),c,i+e,a,s+t):o(H(t,h),N(2*t,y),H(e,x),N(2*e,m),a,s+t,c,i+e);else if(b){const l=Se.getPrimitive();v(e,g,l),l.applyMatrix4(n);const f=O(t),d=D(t,h);v(f,p,Ie),v(d,p,_e);const y=l.intersectsBox(Ie),x=l.intersectsBox(_e);A=y&&qe(e,f,r,n,o,i,s,c,a+1,l,!u)||x&&qe(e,d,r,n,o,i,s,c,a+1,l,!u),Se.releasePrimitive(l)}else{const f=O(e),d=D(e,x);v(f,g,Fe),v(d,g,ze);const y=l.intersectsBox(Fe),m=l.intersectsBox(ze);if(y&&m)A=qe(t,f,n,r,o,s,i,a,c+1,l,u)||qe(t,d,n,r,o,s,i,a,c+1,l,u);else if(y)if(B)A=qe(t,f,n,r,o,s,i,a,c+1,l,u);else{const e=Se.getPrimitive();e.copy(Fe).applyMatrix4(n);const l=O(t),d=D(t,h);v(l,p,Ie),v(d,p,_e);const y=e.intersectsBox(Ie),g=e.intersectsBox(_e);A=y&&qe(f,l,r,n,o,i,s,c,a+1,e,!u)||g&&qe(f,d,r,n,o,i,s,c,a+1,e,!u),Se.releasePrimitive(e)}else if(m)if(B)A=qe(t,d,n,r,o,s,i,a,c+1,l,u);else{const e=Se.getPrimitive();e.copy(ze).applyMatrix4(n);const l=O(t),f=D(t,h);v(l,p,Ie),v(f,p,_e);const y=e.intersectsBox(Ie),g=e.intersectsBox(_e);A=y&&qe(d,l,r,n,o,i,s,c,a+1,e,!u)||g&&qe(d,f,r,n,o,i,s,c,a+1,e,!u),Se.releasePrimitive(e)}}return A}const Ce=new it,Ee=new o,Re={strategy:0,maxDepth:40,maxLeafTris:10,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,indirect:!1,verbose:!0,range:null};class Xe{static serialize(t,e={}){e={cloneBuffers:!0,...e};const n=t.geometry,r=t._roots,o=t._indirectBuffer,s=n.getIndex();let i;return i=e.cloneBuffers?{roots:r.map((t=>t.slice())),index:s?s.array.slice():null,indirectBuffer:o?o.slice():null}:{roots:r,index:s?s.array:null,indirectBuffer:o},i}static deserialize(t,e,n={}){n={setIndex:!0,indirect:Boolean(t.indirectBuffer),...n};const{index:r,roots:o,indirectBuffer:s}=t,i=new Xe(e,{...n,[w]:!0});if(i._roots=o,i._indirectBuffer=s||null,n.setIndex){const n=e.getIndex();if(null===n){const n=new d(t.index,1,!1);e.setIndex(n)}else n.array!==r&&(n.array.set(r),n.needsUpdate=!0)}return i}get indirect(){return!!this._indirectBuffer}constructor(t,e={}){if(!t.isBufferGeometry)throw new Error("MeshBVH: Only BufferGeometries are supported.");if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.");if((e=Object.assign({...Re,[w]:!1},e)).useSharedArrayBuffer&&"undefined"==typeof SharedArrayBuffer)throw new Error("MeshBVH: SharedArrayBuffer is not available.");this.geometry=t,this._roots=null,this._indirectBuffer=null,e[w]||(Q(this,e),!t.boundingBox&&e.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new o))),this.resolveTriangleIndex=e.indirect?t=>this._indirectBuffer[t]:t=>t}refit(t=null){return(this.indirect?oe:qt)(this,t)}traverse(t,e=0){const n=this._roots[e],r=new Uint32Array(n),o=new Uint16Array(n);!function e(s,i=0){const a=2*s,c=o[a+15]===x;if(c){const e=r[s+6],l=o[a+14];t(i,c,new Float32Array(n,4*s,6),e,l)}else{const o=s+8,a=r[s+6],l=r[s+7];t(i,c,new Float32Array(n,4*s,6),l)||(e(o,i+1),e(a,i+1))}}(0)}raycast(t,e=p,n=0,r=1/0){const o=this._roots,s=this.geometry,i=[],a=e.isMaterial,c=Array.isArray(e),l=s.groups,u=a?e.side:e,f=this.indirect?se:Rt;for(let s=0,a=o.length;s<a;s++){const o=c?e[l[s].materialIndex].side:u,a=i.length;if(f(this,s,o,t,i,n,r),c){const t=l[s].materialIndex;for(let e=a,n=i.length;e<n;e++)i[e].face.materialIndex=t}}return i}raycastFirst(t,e=p,n=0,r=1/0){const o=this._roots,s=this.geometry,i=e.isMaterial,a=Array.isArray(e);let c=null;const l=s.groups,u=i?e.side:e,f=this.indirect?ce:Nt;for(let s=0,i=o.length;s<i;s++){const o=f(this,s,a?e[l[s].materialIndex].side:u,t,n,r);null!=o&&(null==c||o.distance<c.distance)&&(c=o,a&&(o.face.materialIndex=l[s].materialIndex))}return c}intersectsGeometry(t,e){let n=!1;const r=this._roots,o=this.indirect?ge:Wt;for(let s=0,i=r.length;s<i&&(n=o(this,s,t,e),!n);s++);return n}shapecast(t){const e=lt.getPrimitive(),n=this.indirect?Et:Vt;let{boundsTraverseOrder:r,intersectsBounds:o,intersectsRange:s,intersectsTriangle:i}=t;if(s&&i){const t=s;s=(r,o,s,a,c)=>!!t(r,o,s,a,c)||n(r,o,this,i,s,a,e)}else s||(s=i?(t,r,o,s)=>n(t,r,this,i,o,s,e):(t,e,n)=>n);let a=!1,c=0;const l=this._roots;for(let t=0,e=l.length;t<e;t++){const e=l[t];if(a=yt(this,t,o,s,r,c),a)break;c+=e.byteLength}return lt.releasePrimitive(e),a}bvhcast(t,e,n){let{intersectsRanges:r,intersectsTriangles:o}=n;const s=lt.getPrimitive(),i=this.geometry.index,a=this.geometry.attributes.position,c=this.indirect?t=>{const e=this.resolveTriangleIndex(t);zt(s,3*e,i,a)}:t=>{zt(s,3*t,i,a)},u=lt.getPrimitive(),f=t.geometry.index,d=t.geometry.attributes.position,p=t.indirect?e=>{const n=t.resolveTriangleIndex(e);zt(u,3*n,f,d)}:t=>{zt(u,3*t,f,d)};if(o){const t=(t,n,r,i,a,l,f,d)=>{for(let h=r,y=r+i;h<y;h++){p(h),u.a.applyMatrix4(e),u.b.applyMatrix4(e),u.c.applyMatrix4(e),u.needsUpdate=!0;for(let e=t,r=t+n;e<r;e++)if(c(e),s.needsUpdate=!0,o(s,u,e,h,a,l,f,d))return!0}return!1};if(r){const e=r;r=function(n,r,o,s,i,a,c,l){return!!e(n,r,o,s,i,a,c,l)||t(n,r,o,s,i,a,c,l)}}else r=t}return function(t,e,n,r){if(Ve)throw new Error("MeshBVH: Recursive calls to bvhcast not supported.");Ve=!0;const o=t._roots,s=e._roots;let i,a=0,c=0;const u=(new l).copy(n).invert();for(let t=0,e=o.length;t<e;t++){Me.setBuffer(o[t]),c=0;const e=Se.getPrimitive();v(0,Me.float32Array,e),e.applyMatrix4(u);for(let t=0,o=s.length;t<o&&(Ue.setBuffer(s[t]),i=qe(0,0,n,u,r,a,c,0,0,e),Ue.clearBuffer(),c+=s[t].length,!i);t++);if(Se.releasePrimitive(e),Me.clearBuffer(),a+=o[t].length,i)break}return Ve=!1,i}(this,t,e,r)}intersectsBox(t,e){return Ce.set(t.min,t.max,e),Ce.needsUpdate=!0,this.shapecast({intersectsBounds:t=>Ce.intersectsBox(t),intersectsTriangle:t=>Ce.intersectsTriangle(t)})}intersectsSphere(t){return this.shapecast({intersectsBounds:e=>t.intersectsBox(e),intersectsTriangle:e=>e.intersectsSphere(t)})}closestPointToGeometry(t,e,n={},r={},o=0,s=1/0){return(this.indirect?ve:re)(this,t,e,n,r,o,s)}closestPointToPoint(t,e={},n=0,r=1/0){return function(t,e,n={},r=0,o=1/0){const s=r*r,i=o*o;let a=1/0,c=null;if(t.shapecast({boundsTraverseOrder:t=>(xt.copy(e).clamp(t.min,t.max),xt.distanceToSquared(e)),intersectsBounds:(t,e,n)=>n<a&&n<i,intersectsTriangle:(t,n)=>{t.closestPointToPoint(e,xt);const r=e.distanceToSquared(xt);return r<a&&(mt.copy(xt),a=r,c=n),r<s}}),a===1/0)return null;const l=Math.sqrt(a);return n.point?n.point.copy(mt):n.point=mt.clone(),n.distance=l,n.faceIndex=c,n}(this,t,e,n,r)}getBoundingBox(t){t.makeEmpty();return this._roots.forEach((e=>{v(0,new Float32Array(e),Ee),t.union(Ee)})),t}}function He(t,e,n){return null===t?null:(t.point.applyMatrix4(e.matrixWorld),t.distance=t.point.distanceTo(n.ray.origin),t.object=e,t)}const Ne=parseInt(f)>=166,Oe=new u,De=new t,Le=new l,ke=s.prototype.raycast,Ye=i.prototype.raycast,Ze=new t,Ge=new s,We=[];function je(t,e){this.isBatchedMesh?$e.call(this,t,e):Ke.call(this,t,e)}function $e(t,e){if(this.boundsTrees){const n=this.boundsTrees,r=this._drawInfo||this._instanceInfo,o=this._drawRanges||this._geometryInfo,s=this.matrixWorld;Ge.material=this.material,Ge.geometry=this.geometry;const i=Ge.geometry.boundsTree,a=Ge.geometry.drawRange;null===Ge.geometry.boundingSphere&&(Ge.geometry.boundingSphere=new c);for(let i=0,a=r.length;i<a;i++){if(!this.getVisibleAt(i))continue;const a=r[i].geometryIndex;if(Ge.geometry.boundsTree=n[a],this.getMatrixAt(i,Ge.matrixWorld).premultiply(s),!Ge.geometry.boundsTree){this.getBoundingBoxAt(a,Ge.geometry.boundingBox),this.getBoundingSphereAt(a,Ge.geometry.boundingSphere);const t=o[a];Ge.geometry.setDrawRange(t.start,t.count)}Ge.raycast(t,We);for(let t=0,n=We.length;t<n;t++){const n=We[t];n.object=this,n.batchId=i,e.push(n)}We.length=0}Ge.geometry.boundsTree=i,Ge.geometry.drawRange=a,Ge.material=null,Ge.geometry=null}else Ye.call(this,t,e)}function Ke(t,e){if(this.geometry.boundsTree){if(void 0===this.material)return;Le.copy(this.matrixWorld).invert(),Oe.copy(t.ray).applyMatrix4(Le),Ze.setFromMatrixScale(this.matrixWorld),De.copy(Oe.direction).multiply(Ze);const n=De.length(),r=t.near/n,o=t.far/n,s=this.geometry.boundsTree;if(!0===t.firstHitOnly){const n=He(s.raycastFirst(Oe,this.material,r,o),this,t);n&&e.push(n)}else{const n=s.raycast(Oe,this.material,r,o);for(let r=0,o=n.length;r<o;r++){const o=He(n[r],this,t);o&&e.push(o)}}}else ke.call(this,t,e)}function Je(t=-1,e={}){if(!Ne)throw new Error("BatchedMesh: Three r166+ is required to compute bounds trees.");e.indirect&&console.warn('"Indirect" is set to false because it is not supported for BatchedMesh.'),e={...e,indirect:!1,range:null};const n=this._drawRanges||this._geometryInfo,r=this._geometryCount;this.boundsTrees||(this.boundsTrees=new Array(r).fill(null));const o=this.boundsTrees;for(;o.length<r;)o.push(null);if(t<0){for(let t=0;t<r;t++)e.range=n[t],o[t]=new Xe(this.geometry,e);return o}return t<n.length&&(e.range=n[t],o[t]=new Xe(this.geometry,e)),o[t]||null}export{je as acceleratedRaycast,Je as computeBatchedBoundsTree};
